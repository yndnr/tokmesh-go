#!/bin/bash

# ==============================================================================
# TokMesh Code Re-Audit Script
#
# Usage: ./reaudit_all.sh [agent_cmd]
# ==============================================================================

AGENT_CMD="${1:-gemini}"
REPORT_DIR="audit_reports"

if [ ! -d "$REPORT_DIR" ]; then
    echo "Directory $REPORT_DIR does not exist."
    exit 1
fi

echo "Starting Re-Audit Process..."

# Iterate over all .md files in audit_reports, excluding existing _reaudit.md files
find "$REPORT_DIR" -name "*.md" -not -name "*_reaudit.md" | sort | while read -r report_file; do
    
    # Calculate expected output filename
    # e.g. audit_reports/xyz.md -> audit_reports/xyz_reaudit.md
    output_path="${report_file%.md}_reaudit.md"
    
    # SKIP if re-audit already exists
    if [ -f "$output_path" ]; then
        # echo "  [SKIP] Re-audit already exists: $output_path"
        continue
    fi

    echo "--------------------------------------------------------"
    echo "Processing Report: $report_file"

    # 1. Reverse Engineer Source File Path
    filename=$(basename "$report_file")
    base="${filename%.md}"
    
    # Attempt 1: All underscores -> slashes
    candidate_base="${base//_//}"
    candidate_path="${candidate_base}.go"
    
    target_file=""
    
    if [ -f "$candidate_path" ]; then
        target_file="$candidate_path"
    else
        # Attempt 2: Handle files with underscores in their name (rare but possible)
        # e.g., src/pkg/crypto/adaptive/aes_gcm.go -> src_pkg_crypto_adaptive_aes_gcm.md
        # Strategy: Iterate backwards, replacing the last slash with an underscore
        try2="${candidate_base%/*}_${candidate_base##*/}.go"
        if [ -f "$try2" ]; then
             target_file="$try2"
        fi
    fi

    if [ -z "$target_file" ]; then
        echo "  [SKIP] Could not locate source file for report: $report_file"
        continue
    fi
    
    echo "  Source File: $target_file"
    
    # 2. Prepare Content
    REPORT_CONTENT=$(cat "$report_file")
    SOURCE_CONTENT=$(cat "$target_file")
    
    if [ -z "$REPORT_CONTENT" ] || [ -z "$SOURCE_CONTENT" ]; then
        echo "  [SKIP] Empty report or source file."
        continue
    fi

    # 3. Construct Prompt
    FULL_PROMPT="
You are a Lead Code Reviewer and Security Architect.

I have an Audit Report (generated by an automated agent) and the actual Source Code.
Your goal is to VERIFY the findings in the Audit Report against the Source Code.

---
[AUDIT REPORT]
"""
$REPORT_CONTENT
"""

---
[SOURCE CODE] ($target_file)
"""
$SOURCE_CONTENT
"""

---
[TASK]
1. Read the Audit Report carefully.
2. Check the Source Code to confirm if the reported issues are valid.
   - Are the \"Critical\" (‰∏•Èáç) issues actually present?
   - Are there any False Positives (e.g., code actually handles the case, or it's not applicable)?
   - Verify if Specification Alignment issues are valid (missing tags etc).
3. Prioritize the fixes.

[OUTPUT FORMAT]
Output a Markdown \"Re-Audit Assessment\" with the following sections. Do NOT output introductory text.

# üõ°Ô∏è Re-Audit Assessment: [Filename]

## üî¥ Confirmed Critical Issues
(List issues that are definitely present and dangerous. Explain WHY based on the code provided.)
- **Issue**: ...
- **Verification**: ...
- **Fix Priority**: P0 (Immediate)

## ‚ö†Ô∏è Valid Warnings
(List issues that are valid but less critical.)
- **Issue**: ...
- **Fix Priority**: P1/P2

## üü¢ False Positives / Invalid
(List issues from the report that are NOT actually problems, citing lines in code that prove it.)

## üõ†Ô∏è Action Plan
(Concise checklist of what needs to be changed in this file.)
"

    # 4. Run Agent
    # Redirect stdin to /dev/null to prevent eating loop input
    "$AGENT_CMD" "$FULL_PROMPT" < /dev/null > "$output_path" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "  [OK] Re-audit saved: $output_path"
    else
        echo "  [FAIL] Agent command failed."
    fi

done

echo "--------------------------------------------------------"
echo "Re-Audit Complete."

# PT-03 一种面向会话管理系统的令牌零明文存储架构及高性能哈希索引方法

**专利编号**: PT-03
**技术领域**: 安全与加密
**创新性评估**: 高
**关联文档**: RQ-0101, RQ-0102, DS-0101, AD-0101
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及计算机信息安全技术领域，具体涉及一种面向会话管理系统的令牌零明文存储架构及高性能哈希索引方法，适用于需要高安全性和高性能令牌校验的分布式身份认证系统。

---

## 二、背景技术

### 2.1 现有技术描述

在身份认证系统中，令牌（Token）是验证用户身份和授权的核心凭证。常见的令牌存储方案包括：

1. **明文存储**：直接将令牌原文存储在数据库中。
2. **对称加密存储**：使用AES等算法加密令牌后存储。
3. **JWT自包含令牌**：将用户信息编码在令牌中，通过签名验证。

### 2.2 现有技术的缺陷

1. **明文存储的安全风险**：
   - 数据库泄露将导致所有令牌被批量窃取
   - 攻击者可直接使用泄露的令牌冒充用户
   - 内部人员可能滥用访问权限

2. **对称加密存储的问题**：
   - 加密密钥管理复杂，密钥泄露等同于明文泄露
   - 每次校验需要解密操作，增加计算开销
   - 密钥轮换困难，影响业务连续性

3. **JWT方案的局限**：
   - 无法主动撤销令牌（除非维护黑名单）
   - 令牌体积大，增加网络传输开销
   - 无法限制令牌使用次数

4. **性能瓶颈**：
   - 高并发场景下，令牌校验成为系统瓶颈
   - 传统数据库索引在海量令牌下查询效率下降

---

## 三、发明内容

### 3.1 要解决的技术问题

本发明要解决的技术问题是：如何在保证高安全性（令牌泄露后无法使用）的同时，实现高性能的令牌校验（O(1)时间复杂度）。

### 3.2 技术方案

本发明提供一种面向会话管理系统的令牌零明文存储架构及高性能哈希索引方法，包括：

#### 3.2.1 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端                                  │
│  持有令牌明文：tmt_a3f8b2c1d4e5f6g7h8i9j0k1l2m3n4o5         │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 携带令牌发起请求
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    令牌校验服务                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  哈希计算模块                         │   │
│  │  TokenHash = SHA-256(TokenPlaintext)                 │   │
│  │  计算时间：< 1μs                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                              │
│                              ▼                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  索引查询模块                         │   │
│  │  查询 TokenHash → SessionID 映射                     │   │
│  │  时间复杂度：O(1)                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                              │
│                              ▼                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  会话验证模块                         │   │
│  │  检查会话状态、过期时间、权限等                        │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      存储层                                  │
│  ┌───────────────────────┐  ┌───────────────────────┐      │
│  │   TokenHash索引表      │  │     Session存储       │      │
│  │  ┌─────────────────┐  │  │  ┌─────────────────┐  │      │
│  │  │ TokenHash       │──┼──┼─▶│ SessionID       │  │      │
│  │  │ (SHA-256, 32B)  │  │  │  │ UserID          │  │      │
│  │  │        ↓        │  │  │  │ CreatedAt       │  │      │
│  │  │ SessionID       │  │  │  │ ExpiresAt       │  │      │
│  │  └─────────────────┘  │  │  │ Metadata        │  │      │
│  │  （无令牌明文！）      │  │  │ （无令牌明文！）  │  │      │
│  └───────────────────────┘  └───────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2.2 令牌生成流程

```
步骤1：生成高熵随机数
  random_bytes = CSPRNG(32)  // 256位密码学安全随机数

步骤2：编码为令牌明文
  token_plaintext = "tmt_" + Base64URL(random_bytes)
  // 示例：tmt_a3f8b2c1d4e5f6g7h8i9j0k1l2m3n4o5

步骤3：计算令牌哈希
  token_hash = SHA-256(token_plaintext)
  // 32字节哈希值

步骤4：创建会话记录
  session = {
    session_id: GenerateULID(),
    user_id: request.user_id,
    created_at: now(),
    expires_at: now() + TTL,
    // ... 其他元数据
  }

步骤5：建立索引关系
  TokenHashIndex[token_hash] = session.session_id

步骤6：返回令牌（仅此一次）
  response.token = token_plaintext
  // 明文仅在此处返回，不存储、不记录日志
```

#### 3.2.3 令牌校验流程

```
输入：客户端提交的令牌明文 token_plaintext

步骤1：计算哈希
  token_hash = SHA-256(token_plaintext)

步骤2：查询索引
  session_id = TokenHashIndex.Get(token_hash)
  IF session_id == nil THEN
    RETURN Error("令牌无效")
  END IF

步骤3：获取会话
  session = SessionStore.Get(session_id)
  IF session == nil THEN
    RETURN Error("会话不存在")
  END IF

步骤4：验证会话状态
  IF session.expires_at < now() THEN
    RETURN Error("会话已过期")
  END IF
  IF session.status != "active" THEN
    RETURN Error("会话已失效")
  END IF

步骤5：返回验证结果
  RETURN Success(session)
```

#### 3.2.4 高性能哈希索引设计

**索引数据结构**：

```
TokenHashIndex {
    数据结构：分段哈希表（Sharded HashMap）
    分片数量：16（可配置）
    分片路由：Hash(TokenHash) % ShardCount

    单分片结构：
    Shard {
        锁：RWMutex
        数据：map[TokenHash]SessionID
    }
}
```

**索引操作复杂度**：

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 插入 | O(1) | 哈希表插入 |
| 查询 | O(1) | 哈希表查找 |
| 删除 | O(1) | 哈希表删除 |
| 遍历 | O(n) | 仅用于维护任务 |

#### 3.2.5 安全性保证

1. **不可逆性**：SHA-256是单向哈希函数，无法从哈希值还原令牌明文。

2. **唯一性**：256位哈希空间（2^256）保证实际无碰撞。

3. **抗暴力破解**：
   - 令牌本身256位熵，暴力枚举不可行
   - 即使获得哈希值，也无法逆向获得令牌

4. **泄露影响有限**：
   - 数据库泄露：攻击者仅获得哈希值，无法使用
   - 内存泄露：同上，哈希值无法还原令牌

### 3.3 有益效果

1. **极高安全性**：
   - 令牌明文永不存储，杜绝批量泄露风险
   - 即使数据库完全泄露，攻击者也无法获得可用令牌

2. **高性能校验**：
   - 哈希计算 < 1μs
   - 索引查询 O(1)，支持 100,000+ TPS

3. **即时撤销**：
   - 删除哈希索引即可立即撤销令牌
   - 无需等待过期，无需维护黑名单

4. **存储高效**：
   - 仅存储32字节哈希值，空间占用小
   - 无需加密密钥管理

5. **运维简单**：
   - 无密钥轮换需求
   - 数据库备份无安全顾虑

---

## 四、具体实施方式

### 4.1 实施例1：令牌生成

```go
import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
)

// 生成令牌
func GenerateToken() (plaintext string, hash [32]byte, err error) {
    // 步骤1：生成256位随机数
    randomBytes := make([]byte, 32)
    if _, err := rand.Read(randomBytes); err != nil {
        return "", [32]byte{}, err
    }

    // 步骤2：编码为令牌明文
    encoded := base64.RawURLEncoding.EncodeToString(randomBytes)
    plaintext = "tmt_" + encoded

    // 步骤3：计算哈希（用于存储）
    hash = sha256.Sum256([]byte(plaintext))

    return plaintext, hash, nil
}

// 创建会话并返回令牌
func CreateSession(userID string, ttl time.Duration) (*CreateSessionResponse, error) {
    // 生成令牌
    tokenPlaintext, tokenHash, err := GenerateToken()
    if err != nil {
        return nil, err
    }

    // 创建会话
    session := &Session{
        ID:        GenerateSessionID(),
        UserID:    userID,
        CreatedAt: time.Now(),
        ExpiresAt: time.Now().Add(ttl),
        Status:    StatusActive,
    }

    // 存储会话
    if err := sessionStore.Set(session.ID, session); err != nil {
        return nil, err
    }

    // 建立令牌哈希索引
    if err := tokenIndex.Set(tokenHash, session.ID); err != nil {
        sessionStore.Delete(session.ID)  // 回滚
        return nil, err
    }

    // 返回令牌明文（仅此一次！）
    return &CreateSessionResponse{
        SessionID: session.ID,
        Token:     tokenPlaintext,  // 明文仅在此返回
        ExpiresAt: session.ExpiresAt,
    }, nil
}
```

### 4.2 实施例2：令牌校验

```go
// 校验令牌
func ValidateToken(tokenPlaintext string) (*Session, error) {
    // 步骤1：计算哈希
    tokenHash := sha256.Sum256([]byte(tokenPlaintext))

    // 步骤2：查询索引
    sessionID, exists := tokenIndex.Get(tokenHash)
    if !exists {
        return nil, ErrInvalidToken
    }

    // 步骤3：获取会话
    session, err := sessionStore.Get(sessionID)
    if err != nil {
        return nil, ErrSessionNotFound
    }

    // 步骤4：验证状态
    if time.Now().After(session.ExpiresAt) {
        return nil, ErrSessionExpired
    }
    if session.Status != StatusActive {
        return nil, ErrSessionInactive
    }

    return session, nil
}
```

### 4.3 实施例3：分段哈希索引

```go
// 分段哈希索引
type ShardedTokenIndex struct {
    shards    []*tokenShard
    shardMask uint32
}

type tokenShard struct {
    mu   sync.RWMutex
    data map[[32]byte]string  // TokenHash -> SessionID
}

const defaultShardCount = 16

func NewShardedTokenIndex() *ShardedTokenIndex {
    shards := make([]*tokenShard, defaultShardCount)
    for i := range shards {
        shards[i] = &tokenShard{
            data: make(map[[32]byte]string),
        }
    }
    return &ShardedTokenIndex{
        shards:    shards,
        shardMask: uint32(defaultShardCount - 1),
    }
}

// 分片路由
func (idx *ShardedTokenIndex) getShard(hash [32]byte) *tokenShard {
    // 使用哈希值的前4字节作为分片键
    shardKey := binary.BigEndian.Uint32(hash[:4])
    return idx.shards[shardKey&idx.shardMask]
}

// 设置索引
func (idx *ShardedTokenIndex) Set(hash [32]byte, sessionID string) error {
    shard := idx.getShard(hash)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    shard.data[hash] = sessionID
    return nil
}

// 查询索引
func (idx *ShardedTokenIndex) Get(hash [32]byte) (string, bool) {
    shard := idx.getShard(hash)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    sessionID, exists := shard.data[hash]
    return sessionID, exists
}

// 删除索引
func (idx *ShardedTokenIndex) Delete(hash [32]byte) {
    shard := idx.getShard(hash)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    delete(shard.data, hash)
}
```

### 4.4 实施例4：令牌撤销

```go
// 撤销令牌（通过会话ID）
func RevokeSessionTokens(sessionID string) error {
    // 获取会话关联的所有令牌哈希
    session, err := sessionStore.Get(sessionID)
    if err != nil {
        return err
    }

    // 删除令牌索引
    for _, tokenHash := range session.TokenHashes {
        tokenIndex.Delete(tokenHash)
    }

    // 更新会话状态
    session.Status = StatusRevoked
    session.RevokedAt = time.Now()
    return sessionStore.Set(sessionID, session)
}

// 撤销令牌（通过令牌明文 - 用于用户主动登出）
func RevokeToken(tokenPlaintext string) error {
    tokenHash := sha256.Sum256([]byte(tokenPlaintext))

    // 查找关联会话
    sessionID, exists := tokenIndex.Get(tokenHash)
    if !exists {
        return ErrTokenNotFound
    }

    // 删除索引
    tokenIndex.Delete(tokenHash)

    // 从会话中移除该令牌记录
    session, _ := sessionStore.Get(sessionID)
    if session != nil {
        session.RemoveTokenHash(tokenHash)
        sessionStore.Set(sessionID, session)
    }

    return nil
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求 - 系统）

一种面向会话管理系统的令牌零明文存储架构，其特征在于，包括：

**令牌生成模块**，用于生成访问令牌，包括：
- 随机数生成子模块，使用密码学安全随机数生成器生成预定长度的随机字节序列；
- 编码子模块，将所述随机字节序列编码为令牌明文字符串；
- 哈希计算子模块，使用单向哈希函数计算所述令牌明文的哈希值；
其中，所述令牌明文仅在生成时返回给客户端一次，系统内部不存储令牌明文；

**哈希索引模块**，用于建立和维护令牌哈希值与会话标识符的映射关系，所述映射关系存储在内存哈希表中，支持O(1)时间复杂度的查询操作；

**令牌校验模块**，用于校验客户端提交的令牌，包括：
- 接收客户端提交的令牌明文；
- 使用与生成时相同的哈希函数计算令牌哈希值；
- 通过所述哈希索引模块查询对应的会话标识符；
- 验证会话的有效性并返回校验结果；

**会话存储模块**，用于存储会话信息，所述会话信息不包含令牌明文，仅包含令牌哈希值的引用。

### 权利要求2（从属权利要求）

根据权利要求1所述的架构，其特征在于，所述随机数生成子模块生成的随机字节序列长度为32字节（256位），所述哈希计算子模块使用SHA-256算法计算哈希值。

### 权利要求3（从属权利要求）

根据权利要求1所述的架构，其特征在于，所述哈希索引模块采用分段哈希表结构，将索引数据分散到多个独立分片中，每个分片拥有独立的读写锁，以支持高并发访问。

### 权利要求4（从属权利要求）

根据权利要求3所述的架构，其特征在于，所述分段哈希表的分片路由方式为：使用令牌哈希值的前若干字节计算分片索引，将请求路由到对应分片。

### 权利要求5（从属权利要求）

根据权利要求1所述的架构，其特征在于，还包括令牌撤销模块，用于通过删除哈希索引中的映射关系实现令牌的即时撤销，无需等待令牌过期。

### 权利要求6（独立权利要求 - 方法）

一种面向会话管理系统的令牌零明文存储及高性能校验方法，其特征在于，包括以下步骤：

**S1：令牌生成步骤**：
- S1.1：使用密码学安全随机数生成器生成预定长度的随机字节序列；
- S1.2：将随机字节序列编码为令牌明文字符串；
- S1.3：使用单向哈希函数计算令牌明文的哈希值；
- S1.4：建立令牌哈希值与会话标识符的映射关系并存储；
- S1.5：将令牌明文返回给客户端，此后不再存储或传输令牌明文；

**S2：令牌校验步骤**：
- S2.1：接收客户端提交的令牌明文；
- S2.2：使用与生成时相同的哈希函数计算令牌哈希值；
- S2.3：通过哈希索引查询对应的会话标识符，若不存在则返回校验失败；
- S2.4：获取会话信息并验证会话状态，包括过期时间和激活状态；
- S2.5：返回校验结果。

### 权利要求7（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S1.1中，随机字节序列长度为32字节（256位），所述步骤S1.3中，使用SHA-256算法计算哈希值。

### 权利要求8（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S2.3中的哈希索引采用分段哈希表实现，查询时间复杂度为O(1)。

### 权利要求9（从属权利要求）

根据权利要求6所述的方法，其特征在于，还包括令牌撤销步骤：
- S3.1：接收撤销请求，所述请求包含会话标识符或令牌明文；
- S3.2：若提供令牌明文，则计算其哈希值；
- S3.3：从哈希索引中删除对应的映射关系；
- S3.4：更新会话状态为已撤销。

### 权利要求10（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述令牌明文在整个系统生命周期中仅出现在以下位置：
- 生成时的返回响应中；
- 校验时的请求参数中；
- 客户端本地存储中；
系统的任何持久化存储、日志、缓存中均不包含令牌明文。

---

## 六、说明书附图

### 图1：令牌生成流程图

```
┌─────────────┐
│  开始生成   │
└──────┬──────┘
       │
       ▼
┌─────────────────────────┐
│ 调用CSPRNG生成32字节     │
│ 随机数 random_bytes     │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ Base64URL编码           │
│ encoded = encode(       │
│   random_bytes)         │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 添加前缀生成令牌明文     │
│ token = "tmt_" + encoded│
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 计算SHA-256哈希         │
│ hash = SHA256(token)    │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 创建会话记录            │
│ session = {...}         │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 存储哈希索引            │
│ Index[hash] = sessionID │
│ （不存储token明文！）    │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 返回令牌明文给客户端    │
│ （仅此一次返回！）       │
└───────────┬─────────────┘
            │
            ▼
┌─────────────┐
│    结束     │
└─────────────┘
```

### 图2：令牌校验流程图

```
┌─────────────────────────┐
│ 客户端提交令牌明文       │
│ token_plaintext         │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 计算SHA-256哈希         │
│ hash = SHA256(token)    │
│ 耗时: < 1μs             │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│ 查询哈希索引            │
│ sessionID = Index[hash] │
│ 复杂度: O(1)            │
└───────────┬─────────────┘
            │
      ┌─────┴─────┐
      │ 存在?     │
      └─────┬─────┘
       │         │
    是 │         │ 否
       ▼         ▼
┌──────────┐  ┌──────────┐
│ 获取会话 │  │ 返回错误 │
│ session  │  │ 令牌无效 │
└────┬─────┘  └──────────┘
     │
     ▼
┌─────────────────────────┐
│ 验证会话状态            │
│ - 检查过期时间          │
│ - 检查激活状态          │
└───────────┬─────────────┘
            │
      ┌─────┴─────┐
      │ 有效?     │
      └─────┬─────┘
       │         │
    是 │         │ 否
       ▼         ▼
┌──────────┐  ┌──────────┐
│ 返回成功 │  │ 返回错误 │
│ + 会话   │  │ 会话失效 │
└──────────┘  └──────────┘
```

### 图3：数据存储对比图

```
传统方案（明文/加密存储）：
┌─────────────────────────────────────────────┐
│                   数据库                     │
│  ┌─────────────────────────────────────┐   │
│  │             Tokens 表                │   │
│  │  ┌───────────┬─────────────────┐    │   │
│  │  │ SessionID │ Token (明文/密文)│    │   │
│  │  ├───────────┼─────────────────┤    │   │
│  │  │ sess_001  │ tmt_a3f8b2c1... │ ← │   │  泄露风险！
│  │  │ sess_002  │ tmt_x7y8z9w0... │ ← │   │  可直接使用
│  │  │ sess_003  │ tmt_m1n2o3p4... │ ← │   │
│  │  └───────────┴─────────────────┘    │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘


本发明方案（零明文存储）：
┌─────────────────────────────────────────────┐
│                   存储                       │
│  ┌─────────────────────────────────────┐   │
│  │          TokenHash 索引              │   │
│  │  ┌─────────────────┬───────────┐    │   │
│  │  │ TokenHash       │ SessionID │    │   │
│  │  ├─────────────────┼───────────┤    │   │
│  │  │ 7f83b1657ff1... │ sess_001  │    │   │  ✓ 无法还原
│  │  │ 3c363836cf... │ sess_002  │    │   │  ✓ 无法使用
│  │  │ 8f14e45f...     │ sess_003  │    │   │  ✓ 泄露无害
│  │  └─────────────────┴───────────┘    │   │
│  └─────────────────────────────────────┘   │
│                                             │
│  令牌明文在哪里？                            │
│  → 仅存在于客户端！服务端永不存储！          │
└─────────────────────────────────────────────┘
```

---

## 七、摘要

本发明公开了一种面向会话管理系统的令牌零明文存储架构及高性能哈希索引方法。该方案在令牌生成时使用密码学安全随机数生成256位高熵令牌，计算其SHA-256哈希值后仅存储哈希值与会话标识符的映射关系，令牌明文仅在创建时返回给客户端一次，系统内部永不存储。令牌校验时，服务端对客户端提交的令牌计算哈希值，通过O(1)复杂度的哈希索引查询获得会话标识符，再验证会话状态。本发明通过分段哈希表实现高并发支持，解决了传统令牌存储方案中数据库泄露导致凭证批量失窃的安全风险，同时保持了高性能的令牌校验能力。

**关键词**：令牌存储；零明文；哈希索引；SHA-256；会话管理；高性能校验

# PT-02 一种基于敏感度分隔符的标识符命名规范及日志自动脱敏系统

**专利编号**: PT-02
**技术领域**: 安全与加密
**创新性评估**: 高
**关联文档**: RQ-0101, DS-0101, AD-0104
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及计算机信息安全技术领域，具体涉及一种基于敏感度分隔符的标识符命名规范及日志自动脱敏系统，适用于需要在日志中区分和保护敏感信息的分布式系统。

---

## 二、背景技术

### 2.1 现有技术描述

在分布式系统中，各类标识符（ID）和凭证（Credential）被广泛使用，包括：
- 会话ID（Session ID）
- API密钥ID（API Key ID）
- 访问令牌（Access Token）
- API密钥密文（API Secret）

这些标识符在系统运行过程中会被记录到日志中，用于问题排查和审计追踪。

### 2.2 现有技术的缺陷

1. **敏感信息泄露风险**：
   - 日志中混杂着标识符和凭证，难以区分
   - 运维人员可能无意中将包含凭证的日志文件分享或上传
   - 日志聚合系统（如ELK、Splunk）可能暴露敏感信息

2. **脱敏规则复杂**：
   - 传统方案需要维护复杂的正则表达式来匹配不同类型的敏感数据
   - 新增标识符类型时需要同步更新脱敏规则
   - 正则匹配存在漏检和误检风险

3. **开发负担重**：
   - 开发人员需要在每个日志输出点手动判断是否需要脱敏
   - 容易遗漏，导致安全漏洞
   - 代码中充斥着脱敏逻辑，影响可读性

4. **调试效率低**：
   - 过度脱敏导致排查问题时缺乏必要信息
   - 标识符完全脱敏后无法关联上下文
   - 需要频繁查询原始数据

---

## 三、发明内容

### 3.1 要解决的技术问题

本发明要解决的技术问题是：如何通过标识符命名规范本身携带敏感度元信息，使日志组件能够自动识别并脱敏敏感数据，同时保留足够的调试信息。

### 3.2 技术方案

本发明提供一种基于敏感度分隔符的标识符命名规范及日志自动脱敏系统，包括：

#### 3.2.1 标识符命名规范

**格式定义**：`<prefix><type><separator><body>`

| 组成部分 | 说明 | 示例 |
|----------|------|------|
| prefix | 系统统一前缀 | `tm`（TokMesh缩写） |
| type | 标识符类型代码 | `s`(Session), `k`(Key), `t`(Token) |
| separator | **敏感度分隔符** | `-`(公开) 或 `_`(敏感) |
| body | 标识符主体 | ULID或随机字符串 |

**敏感度分隔符规则**：

| 分隔符 | 敏感度 | 含义 | 日志行为 |
|--------|--------|------|----------|
| `-`（连字符） | 公开 | 可安全出现在日志中 | 完整输出 |
| `_`（下划线） | 敏感 | 凭证类，禁止完整输出 | 自动脱敏 |

**标识符类型示例**：

| 类型 | 格式 | 敏感度 | 示例 |
|------|------|--------|------|
| Session ID | `tms-<ULID>` | 公开 | `tms-01ARZ3NDEKTSV4RRFFQ69G5FAV` |
| API Key ID | `tmk-<ULID>` | 公开 | `tmk-01ARZ3NDEKTSV4RRFFQ69G5FAV` |
| Token | `tmt_<random>` | **敏感** | `tmt_a3f8b2c1d4e5...` |
| API Secret | `tms_<random>` | **敏感** | `tms_x7y8z9w0v1u2...` |

#### 3.2.2 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      应用代码层                              │
│  log.Info("用户登录", "session_id", sessionID,              │
│           "token", token, "api_key", apiKeyID)              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   日志处理管道                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              敏感度识别模块                           │   │
│  │  遍历日志字段，识别包含tm前缀的标识符                  │   │
│  │  检查分隔符：`-` → 保留，`_` → 标记为敏感             │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                              │
│                              ▼                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              自动脱敏模块                             │   │
│  │  对标记为敏感的字段执行脱敏：                         │   │
│  │  - 保留前缀和类型（用于识别）                         │   │
│  │  - 保留前N位（用于关联）                              │   │
│  │  - 中间部分替换为***                                  │   │
│  │  - 保留后M位（用于验证）                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                              │
│                              ▼                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              日志输出模块                             │   │
│  │  将处理后的日志输出到文件/控制台/远程                  │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2.3 敏感度识别算法

```
输入：待检查的字符串值 value

步骤1：检查前缀
  IF value 不以系统前缀（如"tm"）开头 THEN
    RETURN (非标识符，不处理)
  END IF

步骤2：提取类型代码
  type = value[2]  // 第3个字符
  IF type 不在已知类型列表 [s, k, t, ...] 中 THEN
    RETURN (非标识符，不处理)
  END IF

步骤3：检查敏感度分隔符
  separator = value[3]  // 第4个字符
  IF separator == '-' THEN
    RETURN (公开标识符，保留原值)
  ELSE IF separator == '_' THEN
    RETURN (敏感凭证，需要脱敏)
  ELSE
    RETURN (格式异常，记录警告)
  END IF
```

#### 3.2.4 脱敏策略

**脱敏输出格式**：`<prefix><type><separator><front>***<tail>`

| 参数 | 默认值 | 说明 |
|------|--------|------|
| front | 4位 | 保留的前部字符数，用于关联同一凭证的多条日志 |
| tail | 4位 | 保留的尾部字符数，用于与原始凭证核对 |
| mask | `***` | 中间部分的替换符号 |

**脱敏示例**：

| 原始值 | 脱敏后 |
|--------|--------|
| `tmt_a3f8b2c1d4e5f6g7h8i9j0` | `tmt_a3f8***j0` |
| `tms_x7y8z9w0v1u2t3s4r5q6` | `tms_x7y8***q6` |

#### 3.2.5 日志字段递归处理

对于结构化日志中的嵌套字段，系统递归处理：

```
输入：日志记录 record（可能包含嵌套结构）

FUNCTION processRecord(record):
  FOR EACH field IN record:
    IF field.value 是字符串 THEN
      field.value = checkAndMask(field.value)
    ELSE IF field.value 是对象或数组 THEN
      processRecord(field.value)  // 递归处理
    END IF
  END FOR
  RETURN record
```

### 3.3 有益效果

1. **零配置脱敏**：通过命名规范本身携带敏感度信息，无需维护复杂的脱敏规则库。

2. **开发友好**：开发人员无需在日志输出时考虑脱敏，系统自动处理。

3. **调试高效**：
   - 公开标识符完整保留，便于跟踪
   - 敏感凭证保留首尾，可用于关联和核对

4. **安全可靠**：
   - 从设计层面杜绝凭证泄露
   - 即使日志外泄，敏感信息也已脱敏

5. **易于扩展**：新增标识符类型时，只需遵循命名规范，无需修改脱敏逻辑。

6. **审计友好**：脱敏后的日志仍可用于安全审计，可追踪操作但无法还原凭证。

---

## 四、具体实施方式

### 4.1 实施例1：标识符生成

```go
// 标识符类型常量
const (
    TypeSession   = 's'  // 会话
    TypeKey       = 'k'  // API密钥
    TypeToken     = 't'  // 令牌
)

// 敏感度分隔符常量
const (
    SepPublic    = '-'  // 公开，可出现在日志
    SepSensitive = '_'  // 敏感，需要脱敏
)

// 生成会话ID（公开）
func GenerateSessionID() string {
    ulid := generateULID()
    return fmt.Sprintf("tm%c%c%s", TypeSession, SepPublic, ulid)
    // 输出示例：tms-01ARZ3NDEKTSV4RRFFQ69G5FAV
}

// 生成API Key ID（公开）
func GenerateAPIKeyID() string {
    ulid := generateULID()
    return fmt.Sprintf("tm%c%c%s", TypeKey, SepPublic, ulid)
    // 输出示例：tmk-01ARZ3NDEKTSV4RRFFQ69G5FAV
}

// 生成Token（敏感）
func GenerateToken() string {
    random := generateSecureRandom(32)  // 256位随机数
    encoded := base64url.Encode(random)
    return fmt.Sprintf("tm%c%c%s", TypeToken, SepSensitive, encoded)
    // 输出示例：tmt_a3f8b2c1d4e5f6g7h8i9j0k1l2m3n4o5
}
```

### 4.2 实施例2：敏感度检测

```go
// 敏感度检测结果
type SensitivityResult struct {
    IsIdentifier bool    // 是否为系统标识符
    IsSensitive  bool    // 是否为敏感凭证
    Type         byte    // 标识符类型
    Original     string  // 原始值
}

// 检测字符串的敏感度
func DetectSensitivity(value string) SensitivityResult {
    result := SensitivityResult{Original: value}

    // 检查最小长度
    if len(value) < 5 {
        return result
    }

    // 检查前缀
    if !strings.HasPrefix(value, "tm") {
        return result
    }

    result.IsIdentifier = true
    result.Type = value[2]

    // 检查分隔符
    separator := value[3]
    switch separator {
    case '-':
        result.IsSensitive = false
    case '_':
        result.IsSensitive = true
    default:
        // 格式异常，保守处理为敏感
        result.IsSensitive = true
    }

    return result
}
```

### 4.3 实施例3：自动脱敏处理器

```go
// 脱敏配置
type MaskConfig struct {
    FrontChars int    // 保留的前部字符数
    TailChars  int    // 保留的尾部字符数
    MaskStr    string // 替换符号
}

var DefaultMaskConfig = MaskConfig{
    FrontChars: 4,
    TailChars:  4,
    MaskStr:    "***",
}

// 执行脱敏
func MaskSensitiveValue(value string, config MaskConfig) string {
    result := DetectSensitivity(value)

    if !result.IsIdentifier {
        return value  // 非标识符，不处理
    }

    if !result.IsSensitive {
        return value  // 公开标识符，不处理
    }

    // 敏感凭证，执行脱敏
    // 保留格式：前缀(2) + 类型(1) + 分隔符(1) + 前N位 + *** + 后M位
    prefix := value[:4]  // "tmt_" 或 "tms_"
    body := value[4:]

    if len(body) <= config.FrontChars + config.TailChars {
        // 主体太短，全部脱敏
        return prefix + config.MaskStr
    }

    front := body[:config.FrontChars]
    tail := body[len(body)-config.TailChars:]

    return prefix + front + config.MaskStr + tail
}
```

### 4.4 实施例4：日志中间件集成

```go
// 日志处理钩子（适配zap、zerolog等日志库）
type SensitivityHook struct {
    config MaskConfig
}

func NewSensitivityHook() *SensitivityHook {
    return &SensitivityHook{config: DefaultMaskConfig}
}

// 处理日志字段
func (h *SensitivityHook) ProcessField(key string, value interface{}) interface{} {
    switch v := value.(type) {
    case string:
        return MaskSensitiveValue(v, h.config)
    case []string:
        masked := make([]string, len(v))
        for i, s := range v {
            masked[i] = MaskSensitiveValue(s, h.config)
        }
        return masked
    case map[string]interface{}:
        return h.processMap(v)
    default:
        return value
    }
}

// 递归处理map
func (h *SensitivityHook) processMap(m map[string]interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    for k, v := range m {
        result[k] = h.ProcessField(k, v)
    }
    return result
}
```

### 4.5 实施例5：使用示例

```go
func main() {
    // 初始化日志器，注入脱敏钩子
    logger := NewLogger(WithHook(NewSensitivityHook()))

    // 生成各类标识符
    sessionID := GenerateSessionID()  // tms-01ARZ3NDEKTSV4RRFFQ69G5FAV
    token := GenerateToken()          // tmt_a3f8b2c1d4e5f6g7h8i9j0k1l2m3n4o5

    // 记录日志（开发人员无需关心脱敏）
    logger.Info("用户登录成功",
        "session_id", sessionID,
        "token", token,
        "user_id", "user123",
    )

    // 实际输出的日志：
    // {
    //   "level": "info",
    //   "msg": "用户登录成功",
    //   "session_id": "tms-01ARZ3NDEKTSV4RRFFQ69G5FAV",  // 完整保留
    //   "token": "tmt_a3f8***n4o5",                       // 自动脱敏
    //   "user_id": "user123"
    // }
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求 - 系统）

一种基于敏感度分隔符的标识符命名规范及日志自动脱敏系统，其特征在于，包括：

**标识符生成模块**，用于按照预定义的命名规范生成系统标识符，所述命名规范的格式为 `<prefix><type><separator><body>`，其中：
- `prefix` 为系统统一前缀；
- `type` 为标识符类型代码；
- `separator` 为敏感度分隔符，使用第一预定字符（如连字符）表示公开标识符，使用第二预定字符（如下划线）表示敏感凭证；
- `body` 为标识符主体内容；

**敏感度识别模块**，用于在日志处理管道中识别符合所述命名规范的标识符，并根据其敏感度分隔符判断该标识符是否为敏感凭证；

**自动脱敏模块**，用于对所述敏感度识别模块判定为敏感凭证的标识符执行脱敏处理，保留标识符的前缀、类型、分隔符以及主体的首尾部分字符，将中间部分替换为预定义的掩码符号；

**日志输出模块**，用于将经过脱敏处理的日志记录输出到目标存储或显示设备。

### 权利要求2（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述第一预定字符为连字符`-`，表示该标识符可安全出现在日志中；所述第二预定字符为下划线`_`，表示该标识符为敏感凭证，禁止完整输出。

### 权利要求3（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述自动脱敏模块采用的脱敏输出格式为 `<prefix><type><separator><front><mask><tail>`，其中 `front` 为保留的前部字符，默认4位；`tail` 为保留的尾部字符，默认4位；`mask` 为中间替换符号，默认为`***`。

### 权利要求4（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述敏感度识别模块还包括递归处理子模块，用于对结构化日志中的嵌套字段进行递归遍历和敏感度检测。

### 权利要求5（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述标识符类型代码包括：
- `s` 表示会话标识符（Session ID）；
- `k` 表示API密钥标识符（API Key ID）；
- `t` 表示访问令牌（Token）；
其中会话标识符和API密钥标识符使用公开分隔符，访问令牌使用敏感分隔符。

### 权利要求6（独立权利要求 - 方法）

一种基于敏感度分隔符的日志自动脱敏方法，其特征在于，包括以下步骤：

**S1：标识符生成步骤**，按照预定义的命名规范生成标识符，所述命名规范在标识符中嵌入敏感度分隔符，使用第一预定字符表示公开标识符，使用第二预定字符表示敏感凭证；

**S2：日志拦截步骤**，在日志输出管道中拦截待输出的日志记录；

**S3：敏感度识别步骤**，遍历日志记录中的各字段值，识别符合所述命名规范的标识符，并根据其敏感度分隔符判断是否为敏感凭证；

**S4：脱敏处理步骤**，对判定为敏感凭证的标识符执行脱敏处理，保留标识符的格式前缀和首尾部分字符，将中间部分替换为掩码符号；

**S5：日志输出步骤**，将脱敏后的日志记录输出到目标位置。

### 权利要求7（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S3中，敏感度识别的具体步骤包括：
- S3.1：检查字段值是否以系统预定义前缀开头；
- S3.2：提取类型代码字符，判断是否为已知类型；
- S3.3：提取敏感度分隔符字符，若为第一预定字符则判定为公开，若为第二预定字符则判定为敏感。

### 权利要求8（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S4中，脱敏处理保留标识符主体的前4位字符和后4位字符，中间部分替换为`***`。

### 权利要求9（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S3还包括递归处理子步骤，用于处理日志记录中的嵌套对象和数组结构。

### 权利要求10（从属权利要求）

根据权利要求6所述的方法，其特征在于，当遇到分隔符字符既非第一预定字符也非第二预定字符的异常情况时，保守地将该标识符视为敏感凭证进行脱敏处理，并记录格式异常警告。

---

## 六、说明书附图

### 图1：标识符结构示意图

```
标识符格式：<prefix><type><separator><body>

示例分解：

公开标识符（Session ID）：
┌────┬────┬────┬──────────────────────────────┐
│ tm │ s  │ -  │ 01ARZ3NDEKTSV4RRFFQ69G5FAV   │
├────┼────┼────┼──────────────────────────────┤
│前缀│类型│公开│           ULID主体            │
│    │    │分隔│                              │
└────┴────┴────┴──────────────────────────────┘
        ↓
   可安全记录到日志


敏感凭证（Token）：
┌────┬────┬────┬──────────────────────────────┐
│ tm │ t  │ _  │ a3f8b2c1d4e5f6g7h8i9j0k1l2   │
├────┼────┼────┼──────────────────────────────┤
│前缀│类型│敏感│         随机字符串主体        │
│    │    │分隔│                              │
└────┴────┴────┴──────────────────────────────┘
        ↓
   需要自动脱敏
```

### 图2：日志处理流程图

```
┌─────────────────┐
│   应用代码       │
│ log.Info(...)   │
└────────┬────────┘
         │ 原始日志
         ▼
┌─────────────────────────────────────────┐
│           日志处理管道                    │
│  ┌─────────────────────────────────┐    │
│  │         字段遍历器               │    │
│  │   遍历所有日志字段值             │    │
│  └──────────────┬──────────────────┘    │
│                 │                        │
│                 ▼                        │
│  ┌─────────────────────────────────┐    │
│  │       敏感度识别器               │    │
│  │  检查前缀 → 提取类型 → 检查分隔符 │    │
│  └──────────────┬──────────────────┘    │
│                 │                        │
│        ┌────────┴────────┐              │
│        ▼                 ▼              │
│  ┌──────────┐      ┌──────────┐        │
│  │ 公开(-)  │      │ 敏感(_)  │        │
│  │ 保留原值 │      │ 执行脱敏 │        │
│  └────┬─────┘      └────┬─────┘        │
│       │                 │               │
│       └────────┬────────┘               │
│                ▼                        │
│  ┌─────────────────────────────────┐    │
│  │         日志输出器               │    │
│  │   输出到文件/控制台/远程         │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
         │
         ▼
┌─────────────────┐
│   安全的日志     │
│   敏感信息已脱敏 │
└─────────────────┘
```

### 图3：脱敏效果对比图

```
脱敏前后对比：

┌─────────────────────────────────────────────────────────┐
│                      原始日志                            │
├─────────────────────────────────────────────────────────┤
│ {                                                       │
│   "msg": "用户登录",                                     │
│   "session_id": "tms-01ARZ3NDEKTSV4RRFFQ69G5FAV",      │
│   "token": "tmt_a3f8b2c1d4e5f6g7h8i9j0k1l2m3n4o5",     │  ← 敏感！
│   "api_key": "tmk-01ARZ3NDEKTSV4RRFFQ69G5FAV",         │
│   "api_secret": "tms_x7y8z9w0v1u2t3s4r5q6p7o8n9m0"     │  ← 敏感！
│ }                                                       │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼ 自动脱敏
┌─────────────────────────────────────────────────────────┐
│                      脱敏后日志                          │
├─────────────────────────────────────────────────────────┤
│ {                                                       │
│   "msg": "用户登录",                                     │
│   "session_id": "tms-01ARZ3NDEKTSV4RRFFQ69G5FAV",      │  ← 完整保留
│   "token": "tmt_a3f8***n4o5",                           │  ← 已脱敏
│   "api_key": "tmk-01ARZ3NDEKTSV4RRFFQ69G5FAV",         │  ← 完整保留
│   "api_secret": "tms_x7y8***n9m0"                       │  ← 已脱敏
│ }                                                       │
└─────────────────────────────────────────────────────────┘

脱敏规则：
- tms-xxx（Session ID）：公开分隔符 '-'，完整保留
- tmt_xxx（Token）：敏感分隔符 '_'，保留前4位+***+后4位
- tmk-xxx（API Key ID）：公开分隔符 '-'，完整保留
- tms_xxx（API Secret）：敏感分隔符 '_'，保留前4位+***+后4位
```

---

## 七、摘要

本发明公开了一种基于敏感度分隔符的标识符命名规范及日志自动脱敏系统。该系统定义了统一的标识符命名格式 `<prefix><type><separator><body>`，通过敏感度分隔符（连字符`-`表示公开，下划线`_`表示敏感）在标识符生成时即嵌入敏感度元信息。日志处理管道在输出日志时自动识别符合规范的标识符，根据分隔符判断敏感度，对敏感凭证执行脱敏处理（保留首尾字符，中间替换为掩码）。本发明解决了传统日志脱敏方案需要维护复杂规则、开发人员需手动处理、容易遗漏导致凭证泄露等问题，实现了零配置、自动化的日志安全防护。

**关键词**：标识符命名规范；敏感度分隔符；日志脱敏；自动识别；信息安全

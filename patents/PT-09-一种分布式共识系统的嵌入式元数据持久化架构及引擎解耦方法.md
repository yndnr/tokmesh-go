# PT-09 一种分布式共识系统的嵌入式元数据持久化架构及引擎解耦方法

**专利编号**: PT-09
**技术领域**: 分布式系统架构
**创新性评估**: 中
**关联文档**: DS-0401, AD-0401
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及分布式系统技术领域，具体涉及一种分布式共识系统的嵌入式元数据持久化架构及引擎解耦方法，适用于基于Raft等共识协议的分布式系统元数据存储场景。

---

## 二、背景技术

### 2.1 现有技术描述

在基于Raft共识协议的分布式系统中，元数据（如集群配置、分片映射、密钥信息）需要通过共识达成一致后进行持久化存储。常见的持久化方案包括：

1. **外部数据库**：使用MySQL、PostgreSQL等关系数据库存储
2. **外部KV存储**：使用etcd、Consul等分布式KV存储
3. **嵌入式存储**：使用LevelDB、RocksDB、BadgerDB等嵌入式存储引擎

### 2.2 现有技术的缺陷

1. **外部存储依赖问题**：
   - 增加系统运维复杂度
   - 外部存储成为单点故障风险
   - 网络延迟影响性能

2. **嵌入式存储耦合问题**：
   - Raft层与存储引擎紧密耦合
   - 更换存储引擎需要大量重构
   - 难以根据场景选择最优引擎

3. **接口不统一**：
   - 不同存储引擎API差异大
   - 业务代码与存储实现绑定
   - 测试和Mock困难

---

## 三、发明内容

### 3.1 要解决的技术问题

本发明要解决的技术问题是：如何设计一种嵌入式元数据持久化架构，使Raft共识层与底层存储引擎解耦，支持灵活更换存储引擎而不影响上层业务逻辑。

### 3.2 技术方案

本发明提供一种分布式共识系统的嵌入式元数据持久化架构及引擎解耦方法，包括：

#### 3.2.1 分层架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                      业务层                                  │
│  ClusterMap / ShardMap / APIKeys / Config                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 读/写请求
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Raft 状态机                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  状态机接口                           │   │
│  │  Apply(entry) → result                               │   │
│  │  Snapshot() → data                                   │   │
│  │  Restore(data) → error                               │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 持久化操作
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 存储抽象层 (Storage Interface)               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  MetadataStore Interface                             │   │
│  │  - Get(key) → value                                  │   │
│  │  - Set(key, value) → error                          │   │
│  │  - Delete(key) → error                              │   │
│  │  - Scan(prefix) → iterator                          │   │
│  │  - Batch(ops) → error                               │   │
│  │  - Snapshot() → reader                              │   │
│  │  - Restore(reader) → error                          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  BadgerDB 实现  │ │  BoltDB 实现    │ │  Memory 实现    │
│                 │ │                 │ │  (测试用)       │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

#### 3.2.2 存储接口定义

```go
// 核心接口定义
type MetadataStore interface {
    // 基本操作
    Get(key []byte) ([]byte, error)
    Set(key, value []byte) error
    Delete(key []byte) error

    // 批量操作
    Batch(ops []BatchOp) error

    // 范围查询
    Scan(prefix []byte) Iterator

    // 快照操作 (用于 Raft 快照)
    Snapshot() (SnapshotReader, error)
    Restore(reader SnapshotReader) error

    // 生命周期
    Close() error
}

type BatchOp struct {
    Type  OpType  // SET / DELETE
    Key   []byte
    Value []byte
}

type Iterator interface {
    Next() bool
    Key() []byte
    Value() []byte
    Error() error
    Close()
}

type SnapshotReader interface {
    io.Reader
    io.Closer
}
```

#### 3.2.3 键空间设计

**键前缀规范**：
```
/meta/cluster/         集群元数据
/meta/shard/           分片映射
/meta/apikey/          API密钥
/meta/config/          配置信息
/raft/log/             Raft日志 (由Raft库管理)
/raft/snapshot/        Raft快照 (由Raft库管理)
```

**键编码规则**：
```
完整键格式: /<namespace>/<type>/<id>

示例:
  /meta/cluster/nodes/node-1     → 节点1的信息
  /meta/shard/map/v3             → 第3版分片映射
  /meta/apikey/tmk-xxx           → 密钥tmk-xxx的元数据
```

#### 3.2.4 Raft状态机集成

```
Raft 日志应用流程：

┌─────────────┐
│ Raft Entry  │
│ (已提交)    │
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│                    状态机 Apply()                         │
│                                                          │
│  1. 解析命令类型 (SET_CLUSTER_MAP / SET_SHARD_MAP / ...)  │
│  2. 验证命令参数                                          │
│  3. 调用 MetadataStore 接口执行持久化                     │
│  4. 更新内存状态                                          │
│  5. 返回执行结果                                          │
└──────────────────────────────────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│                 MetadataStore (存储抽象层)                │
│                                                          │
│  store.Set(key, value)                                   │
│  // 具体实现由注入的引擎决定                              │
└──────────────────────────────────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│                 具体存储引擎 (BadgerDB/BoltDB/...)        │
│                                                          │
│  实际写入磁盘                                             │
└──────────────────────────────────────────────────────────┘
```

#### 3.2.5 快照与恢复

**快照生成流程**：
```
1. Raft 触发快照 (日志条目数超过阈值)
2. 状态机调用 store.Snapshot()
3. 存储引擎返回当前数据的一致性视图
4. 状态机将视图序列化为快照数据
5. Raft 保存快照并压缩旧日志
```

**恢复流程**：
```
1. 节点启动或需要从快照恢复
2. Raft 提供快照数据
3. 状态机调用 store.Restore(reader)
4. 存储引擎清空当前数据
5. 存储引擎从快照数据恢复
6. 状态机更新内存状态
```

### 3.3 有益效果

1. **引擎可替换**：
   - 通过统一接口隔离存储实现
   - 可根据场景选择最优引擎
   - 更换引擎无需修改业务代码

2. **测试友好**：
   - 提供内存实现用于单元测试
   - 无需真实存储即可测试逻辑
   - Mock 简单直接

3. **关注点分离**：
   - Raft层专注于共识逻辑
   - 存储层专注于持久化
   - 业务层专注于数据模型

4. **可扩展性**：
   - 易于添加新的存储引擎实现
   - 支持不同的持久化策略
   - 便于性能调优

---

## 四、具体实施方式

### 4.1 实施例1：存储接口实现（BadgerDB）

```go
type BadgerStore struct {
    db     *badger.DB
    path   string
}

func NewBadgerStore(path string) (*BadgerStore, error) {
    opts := badger.DefaultOptions(path)
    opts.Logger = nil  // 使用自定义日志

    db, err := badger.Open(opts)
    if err != nil {
        return nil, err
    }

    return &BadgerStore{db: db, path: path}, nil
}

func (s *BadgerStore) Get(key []byte) ([]byte, error) {
    var value []byte

    err := s.db.View(func(txn *badger.Txn) error {
        item, err := txn.Get(key)
        if err == badger.ErrKeyNotFound {
            return ErrKeyNotFound
        }
        if err != nil {
            return err
        }

        value, err = item.ValueCopy(nil)
        return err
    })

    return value, err
}

func (s *BadgerStore) Set(key, value []byte) error {
    return s.db.Update(func(txn *badger.Txn) error {
        return txn.Set(key, value)
    })
}

func (s *BadgerStore) Delete(key []byte) error {
    return s.db.Update(func(txn *badger.Txn) error {
        return txn.Delete(key)
    })
}

func (s *BadgerStore) Batch(ops []BatchOp) error {
    return s.db.Update(func(txn *badger.Txn) error {
        for _, op := range ops {
            switch op.Type {
            case OpSet:
                if err := txn.Set(op.Key, op.Value); err != nil {
                    return err
                }
            case OpDelete:
                if err := txn.Delete(op.Key); err != nil {
                    return err
                }
            }
        }
        return nil
    })
}

func (s *BadgerStore) Scan(prefix []byte) Iterator {
    txn := s.db.NewTransaction(false)
    opts := badger.DefaultIteratorOptions
    opts.Prefix = prefix

    return &badgerIterator{
        txn:  txn,
        iter: txn.NewIterator(opts),
    }
}
```

### 4.2 实施例2：存储接口实现（内存，测试用）

```go
type MemoryStore struct {
    mu   sync.RWMutex
    data map[string][]byte
}

func NewMemoryStore() *MemoryStore {
    return &MemoryStore{
        data: make(map[string][]byte),
    }
}

func (s *MemoryStore) Get(key []byte) ([]byte, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    value, ok := s.data[string(key)]
    if !ok {
        return nil, ErrKeyNotFound
    }

    // 返回副本
    result := make([]byte, len(value))
    copy(result, value)
    return result, nil
}

func (s *MemoryStore) Set(key, value []byte) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    // 存储副本
    valueCopy := make([]byte, len(value))
    copy(valueCopy, value)
    s.data[string(key)] = valueCopy
    return nil
}

func (s *MemoryStore) Snapshot() (SnapshotReader, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    // 序列化当前数据
    var buf bytes.Buffer
    enc := gob.NewEncoder(&buf)

    if err := enc.Encode(s.data); err != nil {
        return nil, err
    }

    return &memorySnapshotReader{Reader: &buf}, nil
}

func (s *MemoryStore) Restore(reader SnapshotReader) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    dec := gob.NewDecoder(reader)
    return dec.Decode(&s.data)
}
```

### 4.3 实施例3：Raft状态机集成

```go
type MetadataStateMachine struct {
    store      MetadataStore
    clusterMap *ClusterMap
    shardMap   *ShardMap
    apiKeys    *APIKeyIndex
}

func NewMetadataStateMachine(store MetadataStore) *MetadataStateMachine {
    return &MetadataStateMachine{
        store:      store,
        clusterMap: NewClusterMap(),
        shardMap:   NewShardMap(),
        apiKeys:    NewAPIKeyIndex(),
    }
}

// Apply 实现 Raft FSM 接口
func (sm *MetadataStateMachine) Apply(log *raft.Log) interface{} {
    var cmd Command
    if err := proto.Unmarshal(log.Data, &cmd); err != nil {
        return err
    }

    switch cmd.Type {
    case CmdSetClusterMap:
        return sm.applySetClusterMap(cmd.Payload)
    case CmdSetShardMap:
        return sm.applySetShardMap(cmd.Payload)
    case CmdCreateAPIKey:
        return sm.applyCreateAPIKey(cmd.Payload)
    case CmdRevokeAPIKey:
        return sm.applyRevokeAPIKey(cmd.Payload)
    default:
        return fmt.Errorf("unknown command type: %d", cmd.Type)
    }
}

func (sm *MetadataStateMachine) applySetClusterMap(payload []byte) error {
    var cm ClusterMap
    if err := proto.Unmarshal(payload, &cm); err != nil {
        return err
    }

    // 持久化到存储
    key := []byte("/meta/cluster/map")
    if err := sm.store.Set(key, payload); err != nil {
        return err
    }

    // 更新内存状态
    sm.clusterMap = &cm
    return nil
}

// Snapshot 实现 Raft FSM 接口
func (sm *MetadataStateMachine) Snapshot() (raft.FSMSnapshot, error) {
    reader, err := sm.store.Snapshot()
    if err != nil {
        return nil, err
    }

    return &metadataSnapshot{reader: reader}, nil
}

// Restore 实现 Raft FSM 接口
func (sm *MetadataStateMachine) Restore(rc io.ReadCloser) error {
    defer rc.Close()

    if err := sm.store.Restore(&snapshotReaderAdapter{rc}); err != nil {
        return err
    }

    // 重建内存状态
    return sm.rebuildInMemoryState()
}
```

### 4.4 实施例4：存储引擎工厂

```go
type StoreType string

const (
    StoreTypeBadger StoreType = "badger"
    StoreTypeBolt   StoreType = "bolt"
    StoreTypeMemory StoreType = "memory"
)

type StoreConfig struct {
    Type    StoreType
    Path    string
    Options map[string]interface{}
}

func NewMetadataStore(config StoreConfig) (MetadataStore, error) {
    switch config.Type {
    case StoreTypeBadger:
        return NewBadgerStore(config.Path)
    case StoreTypeBolt:
        return NewBoltStore(config.Path)
    case StoreTypeMemory:
        return NewMemoryStore(), nil
    default:
        return nil, fmt.Errorf("unknown store type: %s", config.Type)
    }
}

// 使用示例
func main() {
    // 生产环境使用 BadgerDB
    prodConfig := StoreConfig{
        Type: StoreTypeBadger,
        Path: "/var/lib/tokmesh/metadata",
    }
    prodStore, _ := NewMetadataStore(prodConfig)

    // 测试环境使用内存存储
    testConfig := StoreConfig{
        Type: StoreTypeMemory,
    }
    testStore, _ := NewMetadataStore(testConfig)
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求 - 架构）

一种分布式共识系统的嵌入式元数据持久化架构，其特征在于，包括三层结构：

**Raft状态机层**，用于接收已提交的Raft日志条目，解析命令并应用到状态机，通过调用存储抽象层实现数据持久化；

**存储抽象层**，定义统一的元数据存储接口，包括：
- 基本操作接口：Get、Set、Delete；
- 批量操作接口：Batch；
- 范围查询接口：Scan；
- 快照操作接口：Snapshot、Restore；

**存储引擎层**，包含一个或多个实现所述存储抽象层接口的具体存储引擎，所述存储引擎可根据配置在运行时选择。

### 权利要求2（从属权利要求）

根据权利要求1所述的架构，其特征在于，所述存储引擎层包括生产环境使用的嵌入式KV存储引擎和测试环境使用的内存存储引擎。

### 权利要求3（从属权利要求）

根据权利要求1所述的架构，其特征在于，所述存储抽象层采用统一的键空间设计，使用前缀区分不同类型的元数据。

### 权利要求4（从属权利要求）

根据权利要求1所述的架构，其特征在于，所述快照操作接口用于支持Raft快照功能，Snapshot方法返回当前数据的一致性视图，Restore方法从快照数据恢复存储状态。

### 权利要求5（独立权利要求 - 方法）

一种分布式共识系统的存储引擎解耦方法，其特征在于，包括以下步骤：

**S1：接口定义步骤**，定义存储抽象接口，包括基本操作、批量操作、范围查询和快照操作；

**S2：引擎实现步骤**，为不同的存储引擎分别实现所述存储抽象接口；

**S3：工厂注册步骤**，将各存储引擎实现注册到存储工厂，支持通过配置选择具体引擎；

**S4：依赖注入步骤**，在系统初始化时，根据配置创建存储引擎实例，注入到Raft状态机；

**S5：统一调用步骤**，Raft状态机通过存储抽象接口进行持久化操作，无需关心底层具体实现。

### 权利要求6（从属权利要求）

根据权利要求5所述的方法，其特征在于，所述步骤S2中的存储引擎包括BadgerDB、BoltDB等嵌入式KV存储引擎和用于测试的内存存储引擎。

---

## 六、说明书附图

### 图1：分层架构示意图

```
┌─────────────────────────────────────────────────────────────┐
│                        业务层                                │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│   │ClusterMap│ │ ShardMap │ │ APIKeys  │ │  Config  │      │
│   └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘      │
│        └────────────┴────────────┴────────────┘             │
│                           │                                  │
└───────────────────────────┼──────────────────────────────────┘
                            │ 读/写请求
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    Raft 状态机层                             │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                 MetadataStateMachine                 │  │
│   │                                                      │  │
│   │  Apply(entry) ──► 解析命令 ──► 调用存储接口          │  │
│   │  Snapshot()   ──► 调用 store.Snapshot()             │  │
│   │  Restore()    ──► 调用 store.Restore()              │  │
│   └─────────────────────────────────────────────────────┘  │
│                           │                                 │
└───────────────────────────┼─────────────────────────────────┘
                            │ 存储抽象接口
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    存储抽象层                                │
│                                                             │
│   interface MetadataStore {                                 │
│       Get(key) → value                                      │
│       Set(key, value) → error                              │
│       Delete(key) → error                                  │
│       Batch(ops) → error                                   │
│       Scan(prefix) → iterator                              │
│       Snapshot() → reader                                  │
│       Restore(reader) → error                              │
│   }                                                         │
│                                                             │
└───────────────────────────┼─────────────────────────────────┘
                            │
            ┌───────────────┼───────────────┐
            │               │               │
            ▼               ▼               ▼
┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐
│   BadgerDB 实现   │ │   BoltDB 实现     │ │   Memory 实现     │
│                   │ │                   │ │                   │
│ 高性能嵌入式KV    │ │ 简单可靠的KV      │ │ 测试/开发用       │
│ LSM树存储         │ │ B+树存储          │ │ 内存Map存储       │
└───────────────────┘ └───────────────────┘ └───────────────────┘
        │                     │                     │
        └─────────────────────┴─────────────────────┘
                              │
                              ▼
                    ┌───────────────────┐
                    │     磁盘/内存     │
                    └───────────────────┘
```

---

## 七、摘要

本发明公开了一种分布式共识系统的嵌入式元数据持久化架构及引擎解耦方法。该架构分为三层：Raft状态机层负责接收已提交的日志条目并应用到状态机；存储抽象层定义统一的存储接口（Get/Set/Delete/Batch/Scan/Snapshot/Restore）；存储引擎层提供接口的具体实现（如BadgerDB、BoltDB、内存存储）。通过存储工厂模式，系统可在运行时根据配置选择具体的存储引擎。本发明解决了传统方案中Raft层与存储引擎紧密耦合、难以更换存储实现的问题，实现了关注点分离、引擎可替换和测试友好的目标。

**关键词**：嵌入式存储；元数据持久化；存储抽象；引擎解耦；Raft状态机

# PT-01 一种基于CPU指令集探测的运行时自适应加密算法选择系统及方法

**专利编号**: PT-01
**技术领域**: 安全与加密
**创新性评估**: 高
**关联文档**: RQ-0201, DS-0201, AD-0201
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及计算机信息安全技术领域，具体涉及一种基于CPU指令集探测的运行时自适应加密算法选择系统及方法，适用于需要在不同硬件环境下实现高性能数据加密的分布式系统。

---

## 二、背景技术

### 2.1 现有技术描述

在现代分布式系统中，数据加密是保障信息安全的基础手段。目前主流的对称加密算法包括：

1. **AES-256-GCM**：高级加密标准的伽罗瓦/计数器模式，安全性高，在支持硬件加速（AES-NI指令集）的CPU上性能优异。

2. **ChaCha20-Poly1305**：流密码算法，不依赖硬件加速，在纯软件实现时性能表现优于AES。

### 2.2 现有技术的缺陷

1. **静态算法选择问题**：传统系统在编译时或配置时固定选择一种加密算法，无法根据运行环境动态优化。

2. **性能差异显著**：
   - 在支持AES-NI的CPU上，AES-GCM性能可达10GB/s以上
   - 在不支持AES-NI的CPU上，AES-GCM性能降至100MB/s左右
   - ChaCha20在无硬件加速时性能稳定在500MB/s左右

3. **接口不一致问题**：不同加密算法的密钥长度、Nonce长度、认证标签长度存在差异，上层应用需要针对不同算法编写不同代码。

4. **部署复杂性**：运维人员需要了解目标服务器的CPU特性，手动配置最优算法，增加了部署和维护成本。

---

## 三、发明内容

### 3.1 要解决的技术问题

本发明要解决的技术问题是：如何在系统启动时自动检测CPU硬件加速能力，动态选择最优加密算法，同时对上层应用提供统一的编程接口。

### 3.2 技术方案

本发明提供一种基于CPU指令集探测的运行时自适应加密算法选择系统，包括：

#### 3.2.1 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                    上层应用接口                          │
│  Encrypt(key, nonce, plaintext) → ciphertext           │
│  Decrypt(key, nonce, ciphertext) → plaintext           │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                  统一加密接口层                          │
│  - 统一密钥长度：32字节（256位）                         │
│  - 统一Nonce长度：12字节（96位）                         │
│  - 统一认证标签长度：16字节（128位）                     │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                算法选择决策引擎                          │
│  ┌─────────────────┐    ┌─────────────────┐            │
│  │ CPU指令集探测器 │───▶│  算法选择器     │            │
│  └─────────────────┘    └─────────────────┘            │
└─────────────────────────────────────────────────────────┘
                           │
           ┌───────────────┴───────────────┐
           ▼                               ▼
┌─────────────────────┐       ┌─────────────────────┐
│  AES-256-GCM 实现   │       │ ChaCha20-Poly1305  │
│  (硬件加速路径)     │       │    实现            │
└─────────────────────┘       │  (软件优化路径)    │
                              └─────────────────────┘
```

#### 3.2.2 CPU指令集探测模块

系统启动时执行以下探测流程：

```
步骤1：读取CPU标识信息
  - x86/x64平台：执行CPUID指令
  - ARM平台：读取系统寄存器或/proc/cpuinfo

步骤2：检测AES硬件加速支持
  - x86/x64：检查CPUID返回值中的AES-NI位（EAX=1, ECX bit 25）
  - ARM：检查ARMv8 Crypto Extension支持

步骤3：记录探测结果
  - 支持硬件加速：标记为 HW_ACCELERATED
  - 不支持硬件加速：标记为 SOFTWARE_ONLY

步骤4：缓存探测结果
  - 将探测结果存储在全局变量中，避免重复探测
```

#### 3.2.3 算法选择决策逻辑

```
IF CPU支持AES硬件加速 THEN
    选择算法 = AES-256-GCM
    记录日志："检测到AES-NI/ARMv8 Crypto，启用AES-256-GCM"
ELSE
    选择算法 = ChaCha20-Poly1305
    记录日志："未检测到硬件加速，启用ChaCha20-Poly1305"
END IF

设置全局加密器实例为选定算法的实现
```

#### 3.2.4 统一接口规范

无论底层使用何种算法，对外接口保持一致：

| 参数 | 规格 | 说明 |
|------|------|------|
| 密钥长度 | 32字节（256位） | AES-256和ChaCha20均使用256位密钥 |
| Nonce长度 | 12字节（96位） | GCM和Poly1305均支持96位Nonce |
| 认证标签长度 | 16字节（128位） | 两种算法均产生128位认证标签 |
| 输出格式 | nonce ‖ ciphertext ‖ tag | 统一的密文格式 |

#### 3.2.5 性能优化措施

1. **探测结果缓存**：CPU特性探测仅在系统启动时执行一次，结果缓存在内存中。

2. **算法实例复用**：预创建加密器实例，避免每次加密时的对象创建开销。

3. **内存预分配**：根据常见数据大小预分配缓冲区，减少内存分配次数。

### 3.3 有益效果

1. **自动化优化**：系统自动选择最优算法，无需人工配置，降低运维复杂度。

2. **性能最大化**：
   - 在支持硬件加速的环境中，充分利用AES-NI指令集，加密性能可达10GB/s以上
   - 在不支持硬件加速的环境中，使用ChaCha20保证稳定的500MB/s性能

3. **接口统一**：上层应用无需关心底层算法差异，降低开发复杂度。

4. **部署灵活**：同一套代码可部署在不同硬件环境，无需针对特定CPU编译。

5. **安全性保证**：两种算法均为业界公认的安全算法，均提供256位安全强度。

---

## 四、具体实施方式

### 4.1 实施例1：x86/x64平台实现

```go
// CPU特性探测
type CPUFeatures struct {
    HasAESNI    bool
    HasAVX      bool
    HasAVX2     bool
}

var cpuFeatures CPUFeatures
var selectedCipher Cipher

func init() {
    // 系统启动时执行探测
    cpuFeatures = detectCPUFeatures()

    if cpuFeatures.HasAESNI {
        selectedCipher = NewAESGCMCipher()
        log.Info("启用AES-256-GCM（硬件加速）")
    } else {
        selectedCipher = NewChaCha20Poly1305Cipher()
        log.Info("启用ChaCha20-Poly1305（软件实现）")
    }
}

func detectCPUFeatures() CPUFeatures {
    // 执行CPUID指令检测CPU特性
    // EAX=1时，ECX的bit 25表示AES-NI支持
    _, _, ecx, _ := cpuid(1, 0)
    return CPUFeatures{
        HasAESNI: (ecx & (1 << 25)) != 0,
    }
}
```

### 4.2 实施例2：ARM平台实现

```go
func detectARMCryptoFeatures() CPUFeatures {
    // 读取/proc/cpuinfo或使用系统调用检测
    // 检查Features字段中是否包含"aes"
    data, _ := ioutil.ReadFile("/proc/cpuinfo")
    hasAES := strings.Contains(string(data), "aes")

    return CPUFeatures{
        HasAESNI: hasAES, // ARM Crypto Extension
    }
}
```

### 4.3 实施例3：统一加密接口

```go
// 统一的加密接口
type Cipher interface {
    // 加密：返回 nonce || ciphertext || tag
    Encrypt(key [32]byte, plaintext []byte) ([]byte, error)

    // 解密：输入 nonce || ciphertext || tag
    Decrypt(key [32]byte, ciphertext []byte) ([]byte, error)

    // 返回算法名称
    Algorithm() string
}

// 全局加密函数
func Encrypt(key [32]byte, plaintext []byte) ([]byte, error) {
    return selectedCipher.Encrypt(key, plaintext)
}

func Decrypt(key [32]byte, ciphertext []byte) ([]byte, error) {
    return selectedCipher.Decrypt(key, ciphertext)
}
```

### 4.4 实施例4：Nonce生成策略

```go
func generateNonce() [12]byte {
    var nonce [12]byte
    // 使用密码学安全的随机数生成器
    _, err := crypto/rand.Read(nonce[:])
    if err != nil {
        panic("随机数生成失败")
    }
    return nonce
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求 - 系统）

一种基于CPU指令集探测的运行时自适应加密算法选择系统，其特征在于，包括：

**CPU指令集探测模块**，用于在系统启动时检测当前运行环境的CPU是否支持加密硬件加速指令集，所述加密硬件加速指令集包括x86/x64平台的AES-NI指令集和ARM平台的ARMv8 Crypto Extension；

**算法选择决策模块**，用于根据所述CPU指令集探测模块的探测结果，自动选择最优的加密算法，当检测到支持硬件加速时选择AES-256-GCM算法，当检测到不支持硬件加速时选择ChaCha20-Poly1305算法；

**统一接口适配模块**，用于对上层应用提供统一的加密解密接口，所述统一接口采用固定的参数规格，包括32字节密钥长度、12字节Nonce长度和16字节认证标签长度，使上层应用无需感知底层具体使用的加密算法；

**加密实现模块**，包括AES-256-GCM实现子模块和ChaCha20-Poly1305实现子模块，用于执行实际的加密和解密操作。

### 权利要求2（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述CPU指令集探测模块在x86/x64平台上通过执行CPUID指令并检查返回值中ECX寄存器的第25位来判断是否支持AES-NI指令集。

### 权利要求3（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述CPU指令集探测模块在ARM平台上通过读取系统信息文件或执行系统调用来检测是否支持ARMv8 Crypto Extension。

### 权利要求4（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述CPU指令集探测模块的探测结果被缓存在内存中，在系统运行期间仅执行一次探测操作。

### 权利要求5（从属权利要求）

根据权利要求1所述的系统，其特征在于，所述统一接口适配模块输出的密文格式为：Nonce || 密文 || 认证标签，其中Nonce为12字节，认证标签为16字节。

### 权利要求6（独立权利要求 - 方法）

一种基于CPU指令集探测的运行时自适应加密算法选择方法，其特征在于，包括以下步骤：

**S1：CPU特性探测步骤**，在系统启动时，通过执行CPU标识指令或读取系统信息，检测当前CPU是否支持加密硬件加速指令集；

**S2：算法选择步骤**，根据步骤S1的探测结果进行判断：
- 若支持硬件加速，则选择AES-256-GCM作为加密算法；
- 若不支持硬件加速，则选择ChaCha20-Poly1305作为加密算法；

**S3：接口统一步骤**，将选定的加密算法封装为统一接口，所述统一接口采用固定的32字节密钥长度、12字节Nonce长度和16字节认证标签长度；

**S4：加密执行步骤**，当接收到加密请求时，使用步骤S2选定的算法和步骤S3定义的统一接口执行加密操作。

### 权利要求7（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S1中，对于x86/x64平台，通过执行CPUID指令（EAX=1）并检查ECX寄存器的第25位来判断AES-NI支持；对于ARM平台，通过检查CPU特性标志中的"aes"字段来判断ARMv8 Crypto Extension支持。

### 权利要求8（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S1的探测结果被缓存，在整个系统运行周期内仅执行一次探测。

### 权利要求9（从属权利要求）

根据权利要求6所述的方法，其特征在于，所述步骤S4中，加密输出格式统一为：12字节Nonce + 可变长度密文 + 16字节认证标签。

### 权利要求10（从属权利要求）

根据权利要求6所述的方法，其特征在于，还包括日志记录步骤，用于在算法选择完成后记录所选算法类型和CPU特性信息，便于运维监控和问题排查。

---

## 六、说明书附图

### 图1：系统架构图

```
┌────────────────────────────────────────────────────────────┐
│                        应用层                               │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐                │
│   │ 会话管理  │  │ 令牌校验  │  │ 数据存储  │                │
│   └────┬─────┘  └────┬─────┘  └────┬─────┘                │
│        │             │             │                       │
│        └─────────────┼─────────────┘                       │
│                      ▼                                     │
│   ┌─────────────────────────────────────────────────┐     │
│   │              统一加密接口                         │     │
│   │  Encrypt(key, plaintext) / Decrypt(key, ct)     │     │
│   └─────────────────────┬───────────────────────────┘     │
└─────────────────────────┼──────────────────────────────────┘
                          │
┌─────────────────────────┼──────────────────────────────────┐
│                         ▼                                  │
│   ┌─────────────────────────────────────────────────┐     │
│   │            算法选择决策引擎                       │     │
│   │  ┌─────────────┐      ┌─────────────┐           │     │
│   │  │ CPU特性探测 │─────▶│  算法选择   │           │     │
│   │  │   (启动时)  │      │   决策器    │           │     │
│   │  └─────────────┘      └──────┬──────┘           │     │
│   └──────────────────────────────┼──────────────────┘     │
│                                  │                         │
│              ┌───────────────────┴───────────────┐        │
│              ▼                                   ▼        │
│   ┌─────────────────────┐         ┌─────────────────────┐ │
│   │   AES-256-GCM       │         │  ChaCha20-Poly1305  │ │
│   │   (硬件加速路径)     │         │    (软件路径)       │ │
│   │                     │         │                     │ │
│   │  ┌───────────────┐  │         │  ┌───────────────┐  │ │
│   │  │   AES-NI      │  │         │  │  SIMD优化     │  │ │
│   │  │   指令集      │  │         │  │  (可选)       │  │ │
│   │  └───────────────┘  │         │  └───────────────┘  │ │
│   └─────────────────────┘         └─────────────────────┘ │
│                        加密引擎层                          │
└────────────────────────────────────────────────────────────┘
```

### 图2：算法选择流程图

```
         ┌─────────────┐
         │  系统启动   │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 检测CPU架构 │
         └──────┬──────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   ┌─────────┐    ┌─────────┐
   │ x86/x64 │    │   ARM   │
   └────┬────┘    └────┬────┘
        │              │
        ▼              ▼
   ┌─────────────┐  ┌─────────────┐
   │执行CPUID   │  │读取系统信息 │
   │检查AES-NI  │  │检查Crypto   │
   └──────┬──────┘  └──────┬──────┘
          │                │
          └───────┬────────┘
                  │
                  ▼
          ┌──────────────┐
          │ 支持硬件加速? │
          └───────┬──────┘
                  │
         ┌────────┴────────┐
         │ 是              │ 否
         ▼                 ▼
   ┌───────────────┐ ┌───────────────┐
   │选择AES-256-GCM│ │选择ChaCha20   │
   │               │ │  -Poly1305   │
   └───────┬───────┘ └───────┬───────┘
           │                 │
           └────────┬────────┘
                    │
                    ▼
           ┌───────────────┐
           │ 初始化加密器  │
           │ 缓存探测结果  │
           └───────────────┘
                    │
                    ▼
           ┌───────────────┐
           │ 系统就绪      │
           │ 等待加密请求  │
           └───────────────┘
```

---

## 七、摘要

本发明公开了一种基于CPU指令集探测的运行时自适应加密算法选择系统及方法。该系统在启动时通过执行CPU标识指令自动检测当前硬件是否支持加密加速指令集（如AES-NI或ARMv8 Crypto Extension），并据此动态选择最优的加密算法——在支持硬件加速时选择AES-256-GCM，否则选择ChaCha20-Poly1305。系统通过统一接口层屏蔽底层算法差异，采用固定的32字节密钥、12字节Nonce和16字节认证标签规格，使上层应用无需感知具体算法。本发明解决了传统静态算法配置在不同硬件环境下性能差异大、部署复杂的问题，实现了加密性能的自动最优化和零配置部署。

**关键词**：自适应加密；CPU指令集探测；AES-NI；ChaCha20-Poly1305；统一接口

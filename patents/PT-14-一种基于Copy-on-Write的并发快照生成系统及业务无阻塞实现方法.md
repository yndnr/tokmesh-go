# PT-14 一种基于Copy-on-Write的并发快照生成系统及业务无阻塞实现方法

**专利编号**: PT-14
**技术领域**: 存储引擎与持久化
**创新性评估**: 高
**关联文档**: DS-0102
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及数据持久化技术领域，具体涉及一种基于Copy-on-Write的并发快照生成系统及业务无阻塞实现方法。

---

## 二、背景技术

### 2.1 现有技术的缺陷

1. **全程持锁方案**：快照期间阻塞所有读写，影响业务
2. **深拷贝方案**：内存占用翻倍，大数据量下不可行
3. **传统COW**：需要操作系统支持，实现受限

---

## 三、发明内容

### 3.1 技术方案

**浅复制视图**：
- 仅在极短时间内持有读锁
- 创建Map指针的浅复制，不复制Session对象
- 释放锁后在后台进行序列化

**后台处理**：
- 序列化、加密、压缩、写入等耗时操作无锁执行
- 业务请求零阻塞

**一致性保证**：
- 快照视图创建时刻的数据一致
- 后续写入不影响快照内容

### 3.2 系统流程

```
┌─────────────────────────────────────────────────────────┐
│                   快照生成流程                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Phase 1: 创建视图 (持锁 < 1ms)                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  mu.RLock()                                      │   │
│  │  snapshot = make(map[string]*Session)            │   │
│  │  for k, v := range data {                       │   │
│  │      snapshot[k] = v  // 浅复制，仅复制指针      │   │
│  │  }                                               │   │
│  │  mu.RUnlock()                                    │   │
│  └─────────────────────────────────────────────────┘   │
│                          │                              │
│                          ▼                              │
│  Phase 2: 后台处理 (无锁)                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │  序列化 ──► 加密 ──► 压缩 ──► 写入磁盘          │   │
│  │  (耗时操作，不阻塞业务)                          │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘

业务请求处理 (并行):
┌─────────────────────────────────────────────────────────┐
│  读请求 ──► 正常读取，无阻塞                            │
│  写请求 ──► 正常写入，不影响已创建的快照视图            │
└─────────────────────────────────────────────────────────┘
```

### 3.3 有益效果

1. **业务零阻塞**：持锁时间 < 1ms
2. **内存高效**：浅复制，无需翻倍内存
3. **一致性视图**：快照时刻数据一致
4. **高并发友好**：快照期间正常服务

---

## 四、具体实施方式

```go
func (s *SessionStore) CreateSnapshot() (*Snapshot, error) {
    // Phase 1: 创建浅复制视图 (极短持锁)
    s.mu.RLock()
    view := make(map[string]*Session, len(s.data))
    for k, v := range s.data {
        view[k] = v  // 仅复制指针
    }
    s.mu.RUnlock()
    // 此时锁已释放，业务请求可正常处理

    // Phase 2: 后台处理 (无锁)
    go func() {
        // 序列化
        data, _ := serialize(view)
        // 加密
        encrypted := encrypt(data)
        // 压缩
        compressed := compress(encrypted)
        // 写入磁盘
        writeToFile(compressed)
    }()

    return &Snapshot{view: view, createdAt: time.Now()}, nil
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求）

一种基于Copy-on-Write的并发快照生成方法，其特征在于：

**S1：视图创建步骤**，在极短时间内持有读锁，创建数据映射的浅复制（仅复制指针，不复制对象），然后释放锁；

**S2：后台处理步骤**，在无锁状态下执行序列化、加密、压缩和写入等耗时操作；

**S3：一致性保证步骤**，快照视图反映创建时刻的数据状态，后续写入不影响快照内容。

### 权利要求2（从属权利要求）

根据权利要求1所述的方法，其特征在于，步骤S1的持锁时间小于1毫秒。

---

## 六、摘要

本发明公开了一种基于Copy-on-Write的并发快照生成系统及业务无阻塞实现方法。在极短时间（<1ms）内持有读锁创建数据映射的浅复制视图，随后释放锁，在后台无锁状态下执行序列化、加密、压缩和写入操作。业务请求在快照期间可正常处理，实现零阻塞。解决了传统方案持锁时间长影响业务、深拷贝内存占用翻倍的问题。

**关键词**：Copy-on-Write；并发快照；浅复制；无阻塞；一致性视图

# PT-12 一种基于分段锁的高性能并发哈希表实现及锁竞争优化方法

**专利编号**: PT-12
**技术领域**: 存储引擎与持久化
**创新性评估**: 中
**关联文档**: RQ-0402, DS-0102, AD-0102
**状态**: 草稿
**创建日期**: 2025-12-18

---

## 一、技术领域

本发明涉及并发数据结构技术领域，具体涉及一种基于分段锁的高性能并发哈希表实现及锁竞争优化方法，适用于高并发读写场景下的内存数据存储。

---

## 二、背景技术

### 2.1 现有技术的缺陷

1. **全局锁方案**：所有操作共享一把锁，高并发下成为瓶颈。
2. **sync.Map**：读多写少场景优秀，但频繁写入时性能不稳定。
3. **无锁方案**：实现复杂，难以保证正确性。

---

## 三、发明内容

### 3.1 技术方案

**分段锁设计**：
- 将哈希表分为N个独立分片（默认16个）
- 每个分片拥有独立的读写锁
- 通过Hash(Key) % N路由到目标分片
- 锁竞争降低至1/N

**系统架构**：
```
┌─────────────────────────────────────────────────────────┐
│                     ShardedMap                          │
├─────────┬─────────┬─────────┬─────────┬───────────────┤
│ Shard 0 │ Shard 1 │ Shard 2 │  ...    │ Shard N-1     │
│ RWMutex │ RWMutex │ RWMutex │         │ RWMutex       │
│ map[]   │ map[]   │ map[]   │         │ map[]         │
└─────────┴─────────┴─────────┴─────────┴───────────────┘

路由：shardIndex = hash(key) & (N-1)
```

### 3.2 有益效果

1. **高吞吐量**：相比全局锁提升N倍并发能力
2. **低延迟**：锁竞争减少，等待时间降低
3. **可预测性**：相比sync.Map，性能更稳定
4. **实现简单**：无需复杂的无锁算法

---

## 四、具体实施方式

```go
type ShardedMap struct {
    shards    []*mapShard
    shardMask uint32
}

type mapShard struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func (m *ShardedMap) getShard(key string) *mapShard {
    hash := fnv32(key)
    return m.shards[hash&m.shardMask]
}

func (m *ShardedMap) Get(key string) (interface{}, bool) {
    shard := m.getShard(key)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    val, ok := shard.data[key]
    return val, ok
}

func (m *ShardedMap) Set(key string, value interface{}) {
    shard := m.getShard(key)
    shard.mu.Lock()
    defer shard.mu.Unlock()
    shard.data[key] = value
}
```

---

## 五、权利要求书

### 权利要求1（独立权利要求）

一种基于分段锁的高性能并发哈希表实现，其特征在于：

**分片存储模块**：将哈希表划分为多个独立分片，每个分片包含独立的读写锁和数据映射；

**路由计算模块**：根据键的哈希值计算目标分片索引；

**并发访问模块**：对同一分片的操作进行锁同步，不同分片的操作可并行执行。

### 权利要求2（从属权利要求）

根据权利要求1所述的哈希表，其特征在于，分片数量为2的幂次（默认16），路由计算使用位与运算：shardIndex = hash(key) & (shardCount - 1)。

---

## 六、摘要

本发明公开了一种基于分段锁的高性能并发哈希表实现。将哈希表分为16个独立分片，每个分片拥有独立读写锁，通过Hash(Key) % 16路由请求。相比全局锁方案，并发能力提升16倍；相比sync.Map，在频繁写入场景下性能更稳定。适用于高并发会话存储等场景。

**关键词**：分段锁；并发哈希表；锁竞争优化；高性能

# AD-0101-Token生成与存储策略

**状态**: 已接受
**决策者**: 架构组
**日期**: 2025-12-11
**技术领域**: 安全 / 数据模型
**相关文档**: RQ-0101-核心数据模型.md, RQ-0301-业务接口规约-OpenAPI.md
**替代**: 无
**被替代**: 无

## 1. 背景
在 `RQ-0101-核心数据模型.md` 和接口定义文档 (`RQ-0301-业务接口规约-OpenAPI.md`) 之间存在关于 `token` 字段的矛盾：
- 数据模型要求 `token` 必填且由客户端提供。
- 接口定义中 `CreateSession` 未包含 `token` 字段。
- 此外，关于 Token 在服务端是明文存储还是哈希存储，定义也不够明确。

作为安全基础设施，我们需要明确 Token 的**来源归属**和**存储形态**。

## 2. 备选方案

### 方案 A: 强制服务端生成
- **逻辑**: 客户端只请求 Session，服务端生成 ID 和 Token 返回。
- **优点**: 保证 Token 的熵和格式统一，安全性高。
- **缺点**: 无法接管遗留系统的 Token；无法直接支持 JWT（JWT 通常由专门的 IdP 签发）。

### 方案 B: 强制客户端提供
- **逻辑**: 客户端生成 Token (或转发上游 Token) 传给服务端。
- **优点**: 灵活性高，易于迁移。
- **缺点**: 依赖客户端的随机数质量；增加了客户端复杂性。

### 方案 C: 混合模式 (服务端兜底)
- **逻辑**: `token` 字段可选。如有则用，如无则生成。
- **优点**: 兼顾灵活性与易用性。

## 3. 决策
选择 **方案 C (混合模式)**，并配合 **Hash 存储** 策略。

### 3.1 生成规则
1.  **CreateSession 接口**: `token` 字段设为 **Optional**。
2.  **情况 1 (客户端未提供)**: 服务端使用 `crypto/rand` 生成 32 字节以上的随机字符串（Base62 编码），作为 Access Token。
3.  **情况 2 (客户端提供)**: 服务端校验长度（< 1KB）后直接使用。这支持了 "Bring Your Own Token" 场景（如迁移现有 Session 或使用 JWT 作为凭证）。

### 3.2 存储规则
为了防止数据库泄露导致 Token 批量失窃：
1.  **服务端永不存储 Token 明文**。
2.  **Hash 算法**: 使用 `SHA-256` 计算 `Hash(Token)`。
    - *注*: Token 具有高熵特性（不像密码），因此使用快速 Hash (SHA-256) 是可接受的，且必须保证高性能查询。此处不使用 bcrypt/Argon2，因为 Token 校验是高频操作 (100k TPS)。
3.  **索引**: 建立 `Hash(Token) -> SessionID` 的唯一索引。

### 3.3 返回值
- 仅在 **情况 1 (服务端生成)** 时，`CreateSession` 的响应中会包含明文 `token`。
- 之后无法再通过任何接口查询到该 Token 的明文。

## 4. 后果
- **正向**: 解决了接口定义的矛盾；提升了数据安全性（由明文转 Hash）；保持了对 JWT/遗留系统的兼容性。
- **负向**: 客户端如果丢失了 Token，无法找回，只能重新创建 Session。这是符合安全最佳实践的。

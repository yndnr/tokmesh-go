# 交互式规约工作流 (Interactive Specification Workflow)

版本: 1.0
状态: 已批准
更新日期: 2025-12-05

## 1. 工作流总览 (Overview)

本文档定义了一套由 AI 辅助的、通过自然语言对话驱动的软件规格说明开发 (SDD) 工作流。其核心理念是将繁琐的文档编写过程，转变为一个动态的、富有创造性的、由 AI 深度参与的‘结对设计’过程。

该工作流旨在：
- **降低门槛**: 任何团队成员都可以通过简单的自然语言触发复杂的规格定义流程。
- **提升效率**: AI 负责处理文件查找、模板填充、格式转换、影响分析等重复性工作。
- **保证规范**: AI 会严格遵循已定义的 SDD 规范，确保所有产出文档的格式和结构一致。
- **激活知识**: AI 作为‘活的文档库’，能在交互中提供建议，并确保决策的可追溯性。

本文档不仅是团队成员的工作指南，也是 AI 代理在新项目中进行自我初始化的‘行为脚本’。

## 2. 核心触发指令 (Triggers)

以下为当前已激活的、用于启动各项工作流的自然语言触发短语（或关键词）。

- **想法捕捉**:
  - `我有一个想法`
  - `I have an idea`
  - `sdd: capture`

- **需求细化**:
  - `我想细化一个需求`
  - `I want to refine a requirement`
  - `sdd: refine [RQ编号]`

- **技术设计**:
  - `我们来设计一个功能`
  - `Let's design a feature`
  - `sdd: design [RQ编号]`

- **设计到开发转换**:
  - `我想继续XXX的实现工作`
  - `Start implementing XXX`
  - `sdd: implement [DS编号]`

- **辅助与管理指令**:
  - `sdd: status`
    - **功能**: 触发“项目规约状态”报告。
  - `sdd: export [目标]`
    *   **功能**: 导出项目规范或工作流配置，实现系统可移植。
  - `sdd: help`
    *   **功能**: 随时列出当前所有可用指令及其描述。

## 3. AI 执行逻辑 (AI Logic)

本部分详细描述了 AI 在接收到上述指令后应遵循的行动步骤。

### 工作流 1: 捕捉新想法 (Capture Workflow)

**指令**: `我有一个想法`

1.  **启动对话**: 回复并请求用户用一两句话描述其想法的核心。
    - *示例回复*: “太棒了！请用一两句话描述一下您的想法核心是什么？”
2.  **交互式挖掘**: 基于用户的初步回答，以多选或开放式问题的形式，进行 2-4 轮的对话，以挖掘想法背后的深层信息。
    - **挖掘维度应包括**:
      - **目标 (Goal)**: 这个想法是为了解决什么问题？（例如：提升用户活跃度、解决技术债等）
      - **范围 (Scope)**: 这个想法的主要影响范围是？（例如：前端体验、后端性能、或是某个特定模块）
      - **关键要素 (Key Elements)**: 构成这个想法的核心要素有哪些？
3.  **总结与确认**: 在讨论结束后，将所有信息汇总成一段结构化的文字，并向用户请求最终确认。
    - *示例回复*: “好的，我将您的想法总结如下：... 您确认以此内容为您想法的最终版本吗？”
4.  **定稿与保存**:
    - 在得到用户确认后，根据项目定义的分层编号规则（`<type>-<LEV><seq>-<slug>.md`），生成一个新的 Capture 文档。
      - `type`: `CP`
      - `LEV`: 分层编码（01-06，详见 document-standards.md）
      - `seq`: 2位序号
      - `slug`: 标题（推荐使用中文）
    - 将总结的完整构思写入该 `CP` 文档。
    - 回复用户，告知文档已创建成功及其路径。
    - *（可选）* 立即触发"影响分析"流程。

### 工作流 2: 细化需求 (Requirement Refinement Workflow)

**指令**: `我想细化一个需求`

1.  **定位需求**:
    - 首先询问用户想细化哪个需求，并提示用户可以提供关键词。
    - 调用 `search_file_content` 工具，在 `1-requirements/` 目录下搜索相关关键词。
    - 将搜索结果以选项列表的形式呈现给用户，让用户选择。
2.  **启动细化讨论**:
    - 在用户选定一个 `RQ` 文档后，调用 `read_file` 工具读取其内容。
    - 基于文档现有内容，提出可供细化的方向，并与用户进行交互式讨论。
    - **细化维度应包括**:
      - 功能分解 (Breaking down features)
      - 验收标准 (Acceptance Criteria)
      - 边界条件与异常情况 (Edge cases and exceptions)
      - 非功能性需求 (Non-functional requirements)
3.  **提出变更方案**:
    - 讨论结束后，总结所有细化点。
    - 向用户提出至少两种变更方案：
      - **A (直接修改)**: 直接更新当前 `RQ` 文档。
      - **B (分解为子需求)**: 创建一个新的 `RQ` 文档，并与当前文档建立关联。
4.  **执行变更**: 根据用户的选择，调用 `replace` 或 `write_file` 工具完成文档操作，并向用户报告结果。

### 工作流 3: 进行技术设计 (Design Workflow)

**指令**: `我们来设计一个功能`

1.  **定位需求**:
    - 询问用户想为哪个需求进行设计，并提示可提供关键词或 `RQ` 编号。
    - 在 `1-requirements/` 目录下定位到目标 `RQ` 文档。
    - 检查该 `RQ` 文档是否已有关联的 `DS` (设计) 文档。
2.  **准备设计环境**:
    - 如果尚无设计文档，则告知用户将创建一份新的 `DS` 文档草稿。
    - 生成新的 `DS` 文档编号和文件名。
3.  **引导设计讨论**:
    - 以设计文档模板 (`D系列模板`) 的结构为蓝本，逐一与用户讨论关键设计章节。
    - **讨论应覆盖**:
      - 架构设计 (Architecture: Microservice vs. Monolith, etc.)
      - 数据模型/数据库设计 (Data Model / Database Design)
      - API 接口设计 (API Design)
      - 关键算法或逻辑 (Key algorithms or logic)
      - 容错与安全设计 (Fault tolerance and security)
4.  **生成设计文档**:
    - 讨论结束后，征求用户同意。
    - 将所有讨论内容整理并填充到新的 `DS` 文档的对应章节中。
    - 调用 `write_file` 创建并写入完整的设计文档。
    - 回复用户，告知设计文档已生成，并等待其评审。

### 工作流 4: 设计到开发转换 (Design-to-Development Workflow)

**指令**: `我想继续XXX的实现工作`

1.  **定位与分析设计**:
    - 要求用户明确指出目标设计文档 `DS` 的编号或名称。
    - 读取该设计文档，并进行“完备性检查”。检查点包括：文档状态是否为`已批准`，以及关键章节（如API、数据模型）是否存在 `[待定]`、`[空]` 等占位符。
2.  **处理不完整的设计**:
    - 如果检查发现设计不完整，则向用户明确报告缺失或待定的部分。
    - 询问用户是否希望现在就完善这些设计，并启动“交互式设计研讨”工作流来补全细节。
3.  **处理完备的设计**:
    - 如果检查通过，则告知用户设计已准备就绪，可以开始分解为具体的开发任务 (`TK` 系列)。
    - 启动“任务分解”交互流程。
4.  **引导任务分解**:
    - 基于设计文档，向用户建议一个核心任务列表的草稿。
    - 与用户讨论每个任务的细节、依赖关系和工作量估算。
    - 讨论结束后，总结并请求用户确认。
5.  **生成任务文档**:
    - 在用户确认后，创建一份新的 `TK` 文档，将所有任务项写入其中。
    - 告知用户开发任务已定义完毕，可以随时分配和执行。

### 工作流 5: 导出功能 (Export Workflow)

**指令**: `sdd: export [目标]`

1.  **确认目标**:
    - 询问用户希望导出哪部分内容：`sdd` (项目规约内容) 还是 `project` (AI初始化提示词)。
2.  **执行导出**:
    - **如果目标是 `sdd`**:
        - 将这些代码块集合到一个单一的、可供复制的文本文件中（`prompts-sdd.txt`），并明确地包含如何使用该脚本的说明。
        - 将此文件创建在**项目根目录**下。
    - **如果目标是 `project`**:
        - **启动交互式导出**: 询问用户是否希望在提示词中嵌入当前项目的内容（想法、需求、设计、代码），并让用户进行多选。
        - **技术栈确认**: 如果用户之前的 ADR 或交互中已经选定了前端/后端技术栈，AI 必须自动识别，并将对应的编码规范（例如 `specs/governance/coding-standards/backend/std-go.md` 或 `specs/governance/coding-standards/frontend/std-react.md`）包含在导出的上下文中。
        - **收集内容**: 根据用户的选择，读取相应的文件内容。对于代码，应提示用户指定要包含的源代码目录，并给出文件大小警告。
        - **生成提示词**: 生成包含“核心身份”、“配置参数”、“嵌入的项目上下文”（含已激活的技术规范）、“工作流触发系统”和“AI执行逻辑”等部分的完整“主初始化提示词”。
        - **写入文件**: 将此增强后的提示词以 Markdown 格式的纯文本形式，创建在**项目根目录**下的 `prompt-project.txt` 文件中。
3.  **提供指导**: 告知用户如何使用导出的文本在新项目中初始化 AI。

## 4. 核心行为: 持续性反思与自我学习 (Core Behavior: Continuous Reflection & Self-Learning)

除了由用户指令触发的显式工作流外，AI 代理还必须遵循一种持续性的、隐式的自我学习行为模式。

1.  **时机 (Timing)**: 在每一个由用户发起的、并成功完成的工作流（如 `sdd: capture`, `sdd: refine`）的末尾，自动触发此行为。
2.  **过程 (Process)**: AI 代理应快速回顾刚刚结束的交互过程，寻找可优化的模式、被用户纠正的错误、或由用户提出的更优实践。
3.  **行动 (Action)**:
    - 如果识别到一个有价值的、可被固化为未来标准行为的“学习点”，AI 代理应以自然的对话方式，向用户提出一个具体的“规则更新建议”。
    - AI 必须明确指出这个建议是为了优化其未来的核心行为。
    - AI **绝不能**在未获得用户明确批准的情况下，自行修改任何规范文档。
    - 经用户批准的“规则”将被视为对“主初始化提示词”的更新，并在未来执行 `sdd: export project` 时被包含在内。
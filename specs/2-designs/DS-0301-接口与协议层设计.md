# DS-0301 - 接口与协议层设计

**状态**: 已批准
**优先级**: P0
**来源**: specs/governance/error-codes.md, RQ-0301-业务接口规约-OpenAPI.md, RQ-0303-业务接口规约-Redis协议.md, RQ-0402-性能与可靠性需求.md
**作者**: Gemini
**创建日期**: 2025-12-12
**最后更新**: 2025-12-18

> **代码骨架对齐（强制）**：本文中出现的任何 `src/` / `internal/` 目录或文件路径，均以 [specs/governance/code-skeleton.md](../governance/code-skeleton.md) 为单一事实来源；如不一致，以该文档为准并同步更新本文。

## 1. 概述

本文档详细设计 TokMesh 的接口与协议层。当前版本聚焦于对外 **HTTP/HTTPS 管理与数据接口**（包含管理、会话与令牌校验等能力），并定义集群内部的 **Connect + Protobuf** 通信边界。设计目标是兼顾可运维性、可观测性与安全默认值。

## 2. 协议架构

TokMesh 采用分层协议策略：

*   **对外管理/数据面**：HTTP/HTTPS（JSON），对外接口行为在明文与加密端口保持一致。
*   **集群内部控制面**：Connect + Protobuf（建议 mTLS），不对外暴露。
*   **Redis**：独立的 Redis 协议解析层（规划项），将 RESP 指令转换为内部业务调用。

### 2.1 端口规划

| 端口 | 协议 | 说明 |
|------|------|------|
| **5080** | HTTP | 业务/管理接口（明文，默认启用且仅本地回环） |
| **5443** | HTTPS | 业务/管理接口（TLS 加密，默认禁用；启用后默认仅本地回环，且需证书） |
| **6379** | RESP | Redis 兼容协议（明文，仅开发环境） |
| **6380** | RESP+TLS | Redis 兼容协议（生产环境） |

#### 2.1.1 监听地址安全策略（防误用）

- **默认仅本地访问**：HTTP 默认监听 `127.0.0.1:5080` / `[::1]:5080`；HTTPS 默认禁用，启用时默认监听 `127.0.0.1:5443` / `[::1]:5443`，避免因遗漏配置导致对外暴露。
- **显式对外暴露**：只有在管理员显式配置监听 `0.0.0.0` / `::`（全网卡）或指定非回环地址时，才对外提供服务。
- **启动告警**：当监听地址为非回环地址时，服务启动日志必须输出显著的安全告警，提醒管理员确认防火墙/TLS/API Key 等安全边界已到位。

#### 2.1.2 HTTP/2 兼容性策略

- **HTTPS 端口（5443）允许协商 HTTP/2**：通过 ALPN 由客户端与服务端协商使用 HTTP/2（h2）或回落到 HTTP/1.1。
- **HTTP/1.1 保底兼容**：服务端不得要求客户端强制使用 HTTP/2；不支持 h2 的客户端必须可用 HTTP/1.1 正常访问。
- **不启用 h2c**：明文端口（5080）不启用 HTTP/2 Cleartext（h2c），避免代理链路兼容性与排障复杂度上升。

### 2.2 架构图

```mermaid
graph TD
    Client[客户端]

    subgraph Protocol Layer
        HTTPAPI[HTTP API Server<br/>:5080/:5443<br/>HTTP/1.1 (5080) + HTTPS(ALPN h2/h1.1)]
        REDIS[Redis Server<br/>:6379/:6380]
        CLUST[Cluster RPC<br/>Connect + Protobuf<br/>内部网络 / mTLS Only]
    end

    subgraph Middleware Layer
        MW[Auth / RateLimit / Metrics / Trace]
    end

    subgraph Service Layer
        S_SESS[Session Service]
        S_AUTH[Auth Service]
        S_CLUST[Cluster Service<br/>内部 mTLS Only]
    end

    Client -->|HTTP REST(JSON)| HTTPAPI
    Client -->|RESP Protocol| REDIS

    HTTPAPI -->|Context Inject| MW
    REDIS -->|Context Inject| MW
    CLUST -->|Context Inject| MW

    MW -->|Validated Request| S_SESS
    MW -->|Validated Request| S_AUTH
    MW -.->|Forbidden| S_CLUST

    style S_CLUST fill:#ff9999
    style HTTPAPI fill:#90EE90
```

### 2.3 对外接口一致性（5080/5443）

- **功能一致**：5080（明文）与 5443（TLS）暴露的路由集合、请求/响应语义、错误码映射必须一致。
- **差异仅在传输安全**：两者唯一差异是是否启用 TLS 加密与证书校验；业务行为不得分叉。

## 3. 集群内部接口（Connect + Protobuf）

本节仅定义集群内部通信边界。对外业务/管理接口以 OpenAPI/HTTP 为准（见第 4 章）。

### 3.1 ClusterService（集群控制面）

**访问控制**:
- **仅限节点间通信**: ClusterService **不对外暴露**
- **mTLS 认证**: 节点间通信必须使用双向 TLS（节点证书）
- **禁止 API Key 访问**: 即使是 `role=admin` 的 API Key 也不能调用此服务

```protobuf
service ClusterService {
  // 节点加入
  rpc Join(JoinRequest) returns (JoinResponse);
  // 获取 Shard Map
  rpc GetShardMap(GetShardMapRequest) returns (GetShardMapResponse);
  // 数据搬迁 (Rebalance)
  rpc TransferShard(stream TransferShardRequest) returns (TransferShardResponse);
}
```

## 4. OpenAPI (HTTP) 接口设计

### 4.1 实现机制
*   使用 stdlib `http.ServeMux` 编写 Handler（满足项目最低 Go 版本要求，见 `specs/governance/coding-standards/backend/std-go.md`）。
*   与 `net/http` 完全兼容，使用标准 `http.Handler` 接口。
*   **推荐**: 使用 stdlib 手动封装 Service 逻辑，零外部依赖。

### 4.1.1 HTTP 实现方案对比

> 裁决依据：对外接口仅 HTTP/HTTPS，且 HTTP 实现优先 stdlib（见 `specs/adrs/AD-0302-对外接口协议与HTTP实现裁决.md`）。

| 维度 | 第三方路由/框架（Chi/Gin 等） | stdlib (手动封装) |
|------|------------------------------|------------------|
| 开发效率 | 高（生态与中间件丰富） | 中（需手动编码） |
| 灵活性 | 中（受框架约束） | 高（完全自定义） |
| 依赖数 | 中-多 | **零** |
| 可维护性 | 中（依赖升级/约束） | 高（标准库语义清晰） |
| **推荐** | ❌ | ✅ |

**决策**: 选择 stdlib http.ServeMux，理由：
1. RQ-0301-业务接口规约-OpenAPI.md 定义了“仅 GET/POST”的方法白名单、严苛模式等特性
2. stdlib `http.ServeMux` 支持路径参数（`{id}` 语法）
3. 零外部依赖，符合项目"简单性优先"原则

### 4.2 路由映射 (Routing)

| HTTP Method | Path | 说明 |
| :--- | :--- | :--- |
| `POST` | `/sessions` | 创建会话 |
| `GET` | `/sessions` | 搜索会话（分页/过滤/字段裁剪） |
| `GET` | `/sessions/{session_id}` | 查询会话（GET 无副作用） |
| `POST` | `/sessions/{session_id}/touch` | Touch 会话（刷新 last_active） |
| `POST` | `/sessions/{session_id}/renew` | 续期 |
| `POST` | `/sessions/{session_id}/revoke` | 吊销（幂等） |
| `POST` | `/users/{user_id}/sessions/revoke` | 按用户批量吊销（幂等；最多 1000） |
| `POST` | `/tokens/validate` | 令牌校验 |

### 4.3 特殊处理
*   **Method Constraint**: 对外业务接口仅使用 `GET` / `POST`（避免中间设备剥离 `PATCH/DELETE` 导致语义丢失；以 `RQ-0301` 为准）。
*   **Status Mapping**: 将 TokMesh 业务错误码 (如 `code: "TM-SESS-4040"`) 映射为 HTTP Status Code，并返回标准 JSON Body。

### 4.3.1 错误码映射规则

> 完整错误码定义请参见 `specs/governance/error-codes.md`（单一事实来源）

#### 业务错误码 → HTTP Status Code
| TokMesh Error Code | HTTP Status | 说明 |
|-------------------|-------------|------|
| TM-SESS-4040 | 404 | Session 不存在 |
| TM-SESS-4041 | 404 | Session 已过期 |
| TM-SESS-4090 | 409 | 会话 ID 已存在 (Conflict) |
| TM-SESS-4091 | 409 | 版本冲突 (Version Conflict)，客户端应重试 |
| TM-SESS-4001 | 400 | 业务规则校验失败 (如 data 超 4KB) |
| TM-SESS-4002 | 429 | 配额超限 |
| TM-TOKN-4000 | 400 | Token 格式错误 (Malformed Token) |
| TM-TOKN-4010 | 401 | Token 无效 (Invalid Token) |
| TM-TOKN-4011 | 401 | Token 已过期 (Token Expired) |
| TM-TOKN-4012 | 401 | Token 已吊销 (Token Revoked) |
| TM-AUTH-4010 | 401 | API Key 无效 |
| TM-AUTH-4030 | 403 | 权限不足 |
| TM-ADMIN-4030 | 403 | 管理权限不足（Admin role required） |
| TM-ARG-1001 | 400 | 参数无效 (Invalid Argument) |
| TM-ARG-1002 | 400 | 缺少必填参数 (Missing Argument) |
| TM-ARG-1003 | 400 | 参数组合冲突 (Argument Conflict) |
| TM-SYS-4000 | 400 | 请求格式错误 (JSON 解析失败) |
| TM-SYS-4290 | 429 | 超过限流 |
| TM-SYS-5000 | 500 | 内部错误 |

## 5. Redis 兼容协议设计

### 5.1 解析器选型
*   默认实现：自研 RESP 解析器与 Redis 协议入口（与代码骨架 `src/internal/server/redisserver/` 对齐），仅覆盖 `RQ-0303-业务接口规约-Redis协议.md` 定义的指令集。
*   Pipeline：支持基础 Pipeline（批量请求/响应），不支持 Redis MULTI/EXEC 事务。
*   TLS：由 TokMesh 自身的 `net/tls` 监听层实现（端口与证书配置以 `RQ-0502-配置管理需求.md` 为准），协议解析层不绑定具体第三方框架。
*   第三方框架：允许清单中包含 `github.com/tidwall/redcon`（P2 可选；见 `specs/adrs/AD-0103-依赖包治理与白名单.md`），但**本项目当前实现选择不引入**，以避免协议语义与依赖路线分叉（仍坚持“简单性优先”）。

### 5.2 指令映射 (Command Mapping)

**标准 Redis 指令** (兼容):
| Redis Command | TokMesh Logic | 备注 |
| :--- | :--- | :--- |
| `GET <key>` | `GetSession` | 返回 Session JSON |
| `SET <key> <value> [EX seconds]` | `CreateSession` / `UpdateSession` | value 为 JSON，需含 token 字段 |
| `DEL <key> ...` | `RevokeSession` | 最多 1000 个 Key |
| `EXPIRE <key> <seconds>` | `RenewSession` | 仅续期 |
| `TTL <key>` | 查询剩余有效期 | - |
| `EXISTS <key>` | 检查会话存在 | - |

**扩展指令** (TM.* 前缀，与 RQ-0303-业务接口规约-Redis协议.md 一致):
| Redis Command | TokMesh Logic | 备注 |
| :--- | :--- | :--- |
| `TM.CREATE <key> <value> [TTL seconds]` | `CreateSession` | 服务端生成 Token 并返回 |
| `TM.VALIDATE <token> [TOUCH]` | `ValidateToken` | 校验令牌有效性；可选 TOUCH 更新 last_active |
| `TM.TOUCH <session_id>` | `TouchSession` | 更新 last_active，不延长 TTL |
| `TM.REVOKE_USER <user_id>` | `RevokeUserSessions` | 按用户批量吊销 |

### 5.2.1 Pipeline 支持

-   **基本 Pipeline**: 支持批量发送指令，减少 RTT
-   **事务限制**:
    -   ❌ 不支持 Redis MULTI/EXEC 事务
    -   ✅ 每个指令独立执行，不保证原子性
-   **性能优化**: Pipeline 模式下吞吐量提升 3-5 倍

### 5.3 安全实现

#### 5.3.1 AUTH 指令
- **生产环境强制 TLS**: **生产环境**必须启用 TLS，禁止明文连接；**开发环境**可酌情启用明文端口（`server.redis.enabled=true`）以简化调试，但需确保仅本地回环访问
- **API Key 传输（推荐）**: `AUTH <api_key_id> <api_key_secret>`
  - 第一个参数: API Key ID
  - 第二个参数: API Key Secret
- **兼容传输**: `AUTH <api_key_id>:<api_key_secret>`（单参数，便于与 HTTP Header 复用）
- **连接状态**: AUTH 成功后，连接进入 Authenticated 状态
- **风险提示**: 即使有 TLS，仍需定期轮转 API Key

#### 5.3.2 TLS 强制
- **配置**: 仅启用 TLS 监听（`server.redis_tls.enabled=true`），并禁用明文监听（`server.redis.enabled=false`）
- **行为**: 明文连接不可用；仅允许 TLS 连接进入 Redis 协议入口

### 5.3.3 TLS 配置

```yaml
# 配置示例（P2 可选能力：Redis 协议兼容）
#
# 注意：
# - Redis 协议兼容属于 P2，可按需启用；未启用时可忽略本节配置。
# - 证书与私钥必须由管理员提供/生成；TokMesh 仓库默认不内置任何私钥文件（避免误用与泄露）。
server:
  redis:
    enabled: false                      # 禁用明文 Redis 监听（仅开发环境可开启）
    address: "127.0.0.1:6379"

  redis_tls:
    enabled: true
    address: "127.0.0.1:6380"
    tls:
      cert_file: "/etc/tokmesh-server/certs/redis.crt"
      key_file: "/etc/tokmesh-server/certs/redis.key"
      client_ca_file: "/etc/tokmesh-server/certs/ca.crt"  # mTLS（可选）
```

双向 TLS (mTLS):
- 节点间通信: 必须启用 mTLS
- 客户端连接: 可选（根据安全需求）

## 6. 中间件设计 (Middleware)

为了保证所有协议的一致性，核心业务逻辑（Service Layer）不处理传输层细节，中间件负责通用切面。

1.  **Context 注入**: 将 API Key、RequestID 注入 `context.Context`；若启用 Tracing（P2，可选）则注入 TraceID。
    *   **Client IP 口径**: 对 HTTP 请求的 `client_ip` 解析必须遵循“可信代理”规则（`security.network.trusted_proxies`，见 `specs/1-requirements/RQ-0502-配置管理需求.md` 7.1.6），避免伪造 Header 绕过 allow_list/审计/限流。
2.  **鉴权 (AuthN)**:
    *   检查 `Authorization: Bearer <api_key>`（推荐）或 `X-API-Key: <api_key>`（兼容）；或 Connection Context (Redis)。
    *   执行 Argon2 校验 (带缓存)。
3.  **限流 (RateLimit)**: 基于 API Key 的令牌桶限流。
4.  **审计 (Audit)**: 记录写操作日志。
*   **可观测性**:
    *   Metrics: 记录 QPS, Latency, Error Rate。
    *   Tracing: 若启用 Tracing（P2，可选）则创建 Span（实现可为 OTEL 或其它实现）。

### 6.1 Middleware 执行顺序

执行顺序（从外到内）：
1.  **RequestID 注入** → 生成 `X-Request-ID`
2.  **Observability (Tracing，可选)** → 若启用则创建 Span
3.  **AuthN (鉴权)** → 校验 API Key，注入 `context.Context`
4.  **RateLimit (限流)** → 检查 QPS 限制
5.  **Audit (审计)** → 记录请求日志（仅写操作）
6.  **Service Layer** → 业务逻辑

失败处理：
-   1-4 阶段失败 → 立即返回错误，后续中间件不执行
-   5 阶段失败 → 记录日志但不影响业务请求

## 7. 验收标准 (Acceptance Criteria)

### 7.1 HTTP
- [ ] **Method Constraint**: 服务端拒绝 `PATCH/DELETE`，仅允许 `GET/POST`。
- [ ] **错误码映射**: 验证业务错误码能正确映射到 HTTP Status Code。

### 7.2 Redis
- [ ] **redis-cli 兼容**: 使用标准 `redis-cli` 能连接并执行 `SET/GET`。
- [ ] **扩展指令**: 验证 `TM.CREATE` 能返回生成的 Token。
- [ ] **TLS 强制**: 验证非 TLS 连接被拒绝 (在配置开启时)。

### 7.3 性能与压测
- [ ] **HTTP 吞吐量**: 单节点支持 ≥ 10,000 TPS (CreateSession + ValidateToken 混合)
- [ ] **HTTP 延迟**: P99 < 10ms (局域网)
- [ ] **Redis 协议兼容性**: 使用 redis-benchmark 工具，QPS ≥ 50,000 (GET/SET)
- [ ] **并发压测**: 1000 并发连接，持续 10 分钟无错误
- [ ] **协议互操作**: 同一 Session 通过 HTTP 创建/查询，通过 Redis 删除

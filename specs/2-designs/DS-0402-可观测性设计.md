# DS-0402 - 可观测性设计

**状态**: 已批准
**优先级**: P0（Metrics/Logging），P2（Tracing 可选）
**来源**: RQ-0403-可观测性需求.md
**作者**: Claude Code
**创建日期**: 2025-12-12
**最后更新**: 2025-12-18

## 1. 概述

本文档详细设计 TokMesh 的可观测性体系：P0 提供指标采集与结构化日志；分布式追踪为 P2 可选能力（默认不启用、不引入 OpenTelemetry 依赖）。设计目标是提供生产级的监控能力，支持故障排查、性能分析和容量规划。

### 1.1 端点设计

可观测性端点与管理 API 共用端口（默认 5080/5443），简化部署和防火墙配置：

| 端点 | 用途 | 鉴权 |
|------|------|------|
| `/metrics` | Prometheus 指标抓取 | 可配置（默认需要鉴权；如需无鉴权抓取必须显式配置 `telemetry.metrics.auth_enabled=false` 且确保仅内网可达） |
| `/health` | 存活探针 | 无 |
| `/ready` | 就绪探针 | 无 |

详细端点实现见 DS-0302-管理接口设计.md 第 3.8 节。

## 2. 整体架构

```mermaid
graph TB
    subgraph TokMesh 节点
        APP[应用层]
        MW[Middleware]
        TRACE[Tracing (OTEL, P2 可选)]
        METRIC[Metrics (Prometheus Exporter)]
        LOG[Logger]
    end

    subgraph 可观测性基础设施
        OTEL[OpenTelemetry Collector (可选)]
        PROM[Prometheus]
        JAEGER[Jaeger/Tempo (可选)]
        LOKI[Loki (外部收集，可选)]
        ALERT[Alertmanager]
    end

    APP --> MW
    MW --> METRIC
    MW --> LOG

    MW -.-> TRACE
    TRACE -.->|OTLP| OTEL
    OTEL -.->|Export| JAEGER
    METRIC -->|Scrape| PROM
    LOG -.->|stdout/file| LOKI
    PROM --> ALERT
```

## 3. 分布式追踪 (Distributed Tracing)（P2 可选）

### 3.1 技术选型

| 维度 | 选择 | 说明 |
|------|------|------|
| **标准** | OpenTelemetry | 厂商中立，社区活跃 |
| **协议** | OTLP/HTTP | 当前验收范围仅要求 HTTP Exporter；gRPC Exporter 作为后续可选扩展 |
| **依赖/库** | `go.opentelemetry.io/otel` | P2 可选（启用 Tracing 时引入，内部 Tracing 库/Exporter；不代表对外 SDK） |

### 3.2 Span 定义

#### 3.2.1 入站请求 Span

```text
# 示例: HTTP 请求 Span
span_name: "http.POST /sessions"
attributes:
  http.method: "POST"
  http.route: "/sessions"
  net.peer.ip: "192.168.1.100"
  tokmesh.api_key_id: "<key_id>"
  tokmesh.request_id: "req-abc123"
```

#### 3.2.2 内部操作 Span

| 操作 | Span Name | 关键属性 |
|------|-----------|----------|
| Session 创建 | `session.create` | `session.id`, `user.id` |
| Token 校验 | `token.validate` | `token.valid`, `session.id` |
| WAL 写入 | `wal.write` | `entries.count`, `bytes.written` |
| Raft 提交 | `raft.commit` | `log.index`, `log.term` |
| Badger GC | `storage.badger.gc` | `operation="value_log_gc"`, `success="true|false"` |

### 3.3 Context 传播

```go
// Middleware 示例
// 说明：此处不直接引用 OTEL 包；具体实现由 tracing 模块提供（默认 noop，可选 OTEL 实现）。
type Tracer interface {
    Enabled() bool
    Extract(ctx context.Context, header http.Header) context.Context
    Start(ctx context.Context, name string) (context.Context, Span)
}

type Span interface {
    End()
    SetAttribute(key, value string)
}

func TracingMiddleware(tracer Tracer, next http.Handler) http.Handler {
    if tracer == nil || !tracer.Enabled() { // 对应配置：telemetry.tracing.enabled（默认 false）
        return next
    }
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从请求头提取 Trace Context
        ctx := tracer.Extract(r.Context(), r.Header)

        // 创建 Span（命名规范：http.<METHOD> <ROUTE>）
        route := r.Method + " " + r.URL.Path // 实现建议：使用路由模式（如 /sessions/{session_id}）替代实际 path
        ctx, span := tracer.Start(ctx, "http."+route)
        defer span.End()

        // 注入 Request ID
        requestID := generateRequestID()
        span.SetAttribute("request.id", requestID)
        w.Header().Set("X-Request-ID", requestID)

        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 3.4 采样策略

| 环境 | 策略 | 采样率 |
|------|------|--------|
| 开发 | AlwaysOn | 100% |
| 测试 | ParentBased | 10% |
| 生产 | ParentBased + RateLimiting | 1% + 100/s |

**配置项**:
- `telemetry.tracing.enabled`（P2，可选，默认 `false`）
- `telemetry.tracing.endpoint`（P2，可选；启用 tracing 时必须配置）
- `telemetry.tracing.sampling_ratio`（P2，可选）

**校验要求（与配置验证一致）**:
- 当 `telemetry.tracing.enabled=true` 时，`telemetry.tracing.endpoint` 必须为非空；否则配置验证失败并阻止启动（错误码规范见 `specs/governance/error-codes.md`，CFG 模块）。

**最小启用示例**（OTLP/HTTP）:
```yaml
telemetry:
  tracing:
    enabled: true
    endpoint: "http://127.0.0.1:4318"
    sampling_ratio: 0.01
```

## 4. 指标 (Metrics)

### 4.1 Prometheus 集成

可观测性端点与管理 API 共用端口，简化部署配置。详见 DS-0302-管理接口设计.md。

```yaml
# 端点配置
server:
  http:
    enabled: true
    address: "127.0.0.1:5080"   # 明文（默认仅本地）
  https:
    enabled: false                  # 默认禁用；证书就绪后显式启用
    address: "127.0.0.1:5443"   # HTTPS（默认仅本地）
telemetry:
  metrics:
    auth_enabled: true         # /metrics 鉴权开关（默认开启；显式设为 false 才允许无鉴权抓取）
```

**生产启用 HTTPS 示例**:
```yaml
server:
  https:
    enabled: true
    address: "0.0.0.0:5443"
    tls:
      cert_file: "/etc/tokmesh-server/certs/server.crt"
      key_file: "/etc/tokmesh-server/certs/server.key"
      # client_ca_file: "/etc/tokmesh-server/certs/client-ca.crt"  # 可选：开启 mTLS
```

| 端点 | 端口 | 鉴权 |
|------|------|------|
| `/metrics` | 5080/5443 | 可配置（默认需要鉴权）；仅 `role=metrics`（或 `role=admin`）可访问；如需无鉴权抓取必须显式配置 `telemetry.metrics.auth_enabled=false` 且确保仅内网可达 |

鉴权头约定（兼容 Prometheus 抓取与 CLI 调试）：
- 推荐：`Authorization: Bearer <api_key>`
- 兼容：`X-API-Key: <api_key>`
- 其中 `<api_key>` 的实际格式为 `<key_id>:<key_secret>`（例如 `<key_id>:<key_secret>`）
| `/health` | 5080/5443 | 无 |
| `/ready` | 5080/5443 | 无 |

### 4.2 指标命名规范

- **前缀**: `tokmesh_`
- **单位后缀**: `_seconds`, `_bytes`, `_total`
- **标签**: 小写，下划线分隔
- **高基数禁止项（必须）**:
  - 禁止将 `session_id`、`token`、`token_hash`、`user_id`、`api_key` 等字段作为 label。
  - HTTP 指标的 `path/route` label 必须使用路由模板（如 `/sessions/{session_id}`），不得使用实际路径（如 `/sessions/tmss-...`）。

### 4.3 核心指标定义

#### 4.3.1 业务指标

```go
// Session 活跃数
var sessionsActive = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "tokmesh_sessions_active_total",
    Help: "Current number of active sessions",
})

// Session 创建计数
var sessionCreateTotal = prometheus.NewCounter(prometheus.CounterOpts{
    Name: "tokmesh_session_create_total",
    Help: "Total number of sessions created",
})

// Token 校验计数器
var tokenValidateCalls = prometheus.NewCounterVec(prometheus.CounterOpts{
    Name: "tokmesh_token_validate_calls_total",
    Help: "Total number of token validation calls",
}, []string{"result"}) // result: valid, invalid, error

// API 请求延迟
var apiRequestDuration = prometheus.NewHistogramVec(prometheus.HistogramOpts{
    Name:    "tokmesh_api_request_duration_seconds",
    Help:    "API request latency distribution",
    Buckets: []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1},
}, []string{"method", "path", "status"})
```

#### 4.3.2 集群指标

```go
// 节点数量
var clusterNodesTotal = prometheus.NewGaugeVec(prometheus.GaugeOpts{
    Name: "tokmesh_cluster_nodes_total",
    Help: "Number of cluster nodes",
}, []string{"status"}) // status: active, down

// 节点奇偶性 (用于偶数节点告警)
var clusterNodesParity = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "tokmesh_cluster_nodes_parity",
    Help: "Cluster node parity (0=odd, 1=even)",
})

// Gossip 传播延迟
var gossipPropagationLag = prometheus.NewHistogram(prometheus.HistogramOpts{
    Name:    "tokmesh_gossip_propagation_lag_seconds",
    Help:    "Estimated gossip propagation delay",
    Buckets: []float64{.01, .05, .1, .5, 1, 2, 5},
})

// 分片数据分布
var shardKeysCount = prometheus.NewGaugeVec(prometheus.GaugeOpts{
    Name: "tokmesh_shard_keys_count",
    Help: "Number of keys per shard",
}, []string{"node_id"})

// 副本复制延迟
var replicationLag = prometheus.NewGaugeVec(prometheus.GaugeOpts{
    Name: "tokmesh_replication_lag_seconds",
    Help: "Replication lag between primary and backup",
}, []string{"from_node", "to_node"})

// 吊销传播窗口（最终一致性）
var sessionRevokePropagationLag = prometheus.NewHistogram(prometheus.HistogramOpts{
    Name:    "tokmesh_session_revoke_propagation_lag_seconds",
    Help:    "Session revoke propagation lag in eventual-consistency mode (time to become not-usable on all nodes)",
    Buckets: []float64{.01, .05, .1, .25, .5, 1, 2, 5, 10},
})
```

#### 4.3.3 资源指标

```go
// CPU 使用率
var cpuUsageRatio = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "tokmesh_cpu_usage_ratio",
    Help: "CPU usage ratio (0-1)",
})

// 内存使用
var memUsageBytes = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "tokmesh_mem_usage_bytes",
    Help: "Memory usage in bytes",
})

// WAL 写入量
var walWriteBytesTotal = prometheus.NewCounter(prometheus.CounterOpts{
    Name: "tokmesh_wal_write_bytes_total",
    Help: "Total bytes written to WAL",
})
```

## 5. 日志 (Logging)

### 5.1 格式规范

**格式**: JSON Lines (每行一个 JSON 对象)

**字段规则**:
- `request_id`：始终输出（用于跨日志关联）。
- `trace_id`/`span_id`：仅在启用 Tracing 且当前请求存在有效 Span 时输出；默认 Tracing 关闭时应省略该字段（避免空值噪声）。
- **输出介质**：默认输出到 stdout（或文件），由部署侧日志采集（如 Promtail/Fluent Bit）转发到 Loki/Elastic 等；TokMesh 不内置“主动 push 日志”的实现。

**示例（默认：Tracing 关闭）**:
```json
{
  "timestamp": "2025-12-12T10:30:00.123Z",
  "level": "INFO",
  "logger": "tokmesh.session",
  "message": "Session created",
  "request_id": "req-001",
  "session_id": "tmss-xxx",
  "user_id": "user123",
  "duration_ms": 5.2
}
```

**示例（Tracing 启用且存在 Span）**:
```json
{
  "timestamp": "2025-12-12T10:30:00.123Z",
  "level": "INFO",
  "logger": "tokmesh.session",
  "message": "Session created",
  "request_id": "req-001",
  "trace_id": "abc123def456",
  "span_id": "789xyz",
  "session_id": "tmss-xxx",
  "user_id": "user123",
  "duration_ms": 5.2
}
```

### 5.2 日志级别

| 级别 | 用途 | 生产环境 |
|------|------|----------|
| DEBUG | 详细调试信息 | 关闭 |
| INFO | 正常业务事件 | 开启 |
| WARN | 潜在问题 | 开启 |
| ERROR | 错误事件 | 开启 |

### 5.3 敏感信息脱敏

```go
// 自动脱敏规则
var redactPatterns = []string{
    `tmtk_[A-Za-z0-9_-]+`,  // Token
    `tmas_[A-Za-z0-9_-]+`,  // API Secret
    `tmth_[A-Za-z0-9_-]+`,  // Token Hash
}

// 脱敏示例
// 输入: "Token validation failed: tmtk_aBcDeF123456"
// 输出: "Token validation failed: tmtk_***REDACTED***"
```

### 5.4 结构化日志库选型

**推荐**: Go stdlib `log/slog`（JSONHandler，零第三方日志依赖）

```go
logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
    Level: slog.LevelInfo,
}))
logger.Info("Session created",
    slog.String("session_id", "tmss-xxx"),
    slog.String("user_id", "user123"),
    slog.Duration("duration", time.Millisecond*5),
)
```

## 6. 告警规则 (Alerting)

### 6.1 P0 告警 (Critical)

立即介入，影响服务可用性或数据安全。

```yaml
# WAL 写入失败
- alert: WALWriteFailure
  expr: increase(tokmesh_wal_fsync_failed_total[5m]) > 0
  for: 1m
  labels:
    severity: critical
  annotations:
    summary: "WAL write failure detected"
    description: "WAL fsync failed {{ $value }} times in 5 minutes"

# 集群脑裂
- alert: ClusterSplitBrain
  expr: tokmesh_cluster_quorum_lost == 1
  for: 30s
  labels:
    severity: critical
  annotations:
    summary: "Cluster quorum lost - possible split brain"

# API Key 验证失败率异常
- alert: HighAuthFailureRate
  expr: |
    sum(rate(tokmesh_token_validate_calls_total{result="invalid"}[5m])) /
    sum(rate(tokmesh_token_validate_calls_total[5m])) > 0.05
  for: 5m
  labels:
    severity: critical
  annotations:
    summary: "High authentication failure rate (>5%)"

# 存储空间不足
- alert: DiskSpaceLow
  expr: node_filesystem_avail_bytes{mountpoint="/data"} / node_filesystem_size_bytes < 0.1
  for: 5m
  labels:
    severity: critical
  annotations:
    summary: "Disk space below 10%"

# 吊销传播窗口严重扩大（最终一致性）
- alert: CriticalSessionRevokePropagationLag
  expr: histogram_quantile(0.99, rate(tokmesh_session_revoke_propagation_lag_seconds_bucket[5m])) > 5
  for: 1m
  labels:
    severity: critical
  annotations:
    summary: "Session revoke propagation lag P99 > 5s"
    description: "Eventual-consistency revoke propagation window is critically large (P99 > 5s). Potential security window expansion."
```

### 6.2 P1 告警 (Warning)

需关注，可能影响性能或稳定性。

```yaml
# Token 校验高延迟
- alert: HighTokenValidateLatency
  expr: histogram_quantile(0.99, rate(tokmesh_api_request_duration_seconds_bucket{path="/tokens/validate"}[5m])) > 0.1
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "Token validation P99 latency > 100ms"

# 资源使用率高
- alert: HighResourceUsage
  expr: tokmesh_cpu_usage_ratio > 0.85 or tokmesh_mem_usage_bytes / tokmesh_mem_limit_bytes > 0.85
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "High resource usage (>85%)"

# 数据倾斜
- alert: DataSkew
  expr: |
    max(tokmesh_shard_keys_count) / avg(tokmesh_shard_keys_count) > 1.3
  for: 10m
  labels:
    severity: warning
  annotations:
    summary: "Data skew detected (>30% variance)"

# 吊销传播窗口过大（最终一致性）
- alert: HighSessionRevokePropagationLag
  expr: histogram_quantile(0.99, rate(tokmesh_session_revoke_propagation_lag_seconds_bucket[5m])) > 2
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "Session revoke propagation lag P99 > 2s"
    description: "Eventual-consistency revoke propagation window is too large (P99 > 2s for 5m)."

# 偶数节点
- alert: EvenNodeCount
  expr: tokmesh_cluster_nodes_parity == 1
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "Cluster has even number of nodes"
```

## 7. 实现架构

### 7.1 依赖库

| 功能 | 库 | 版本 |
|------|-----|------|
| Metrics | `github.com/prometheus/client_golang` | v1.17+ |
| Logging | Go stdlib `log/slog` | Go 1.22+ |
| Tracing（可选） | `go.opentelemetry.io/otel` | v1.21+ |

**实现约束（避免默认引入 OTEL 依赖）**:
- Tracing 必须作为可插拔模块实现：默认提供 “noop tracing”（不产生 span、不依赖 OTEL）。
- 仅当 `telemetry.tracing.enabled=true` 且选择启用 tracing 实现时，才引入 `go.opentelemetry.io/otel` 及相关初始化逻辑。
- 实现方式可选：build tags（如 `-tags tracing`）或独立子包隔离依赖；但默认构建路径不得强制拉入 OTEL 依赖树。

### 7.2 初始化示例

```go
func InitObservability(cfg *Config) (*Observability, error) {
    // 初始化 Tracing（可选）
    // 说明：默认返回 noop tracer；启用并选择 OTEL 实现时，才会引入 OTEL 依赖并创建 exporter。
    tracer, err := tracing.New(cfg.Tracing) // cfg.Tracing.Enabled 对应 telemetry.tracing.enabled
    if err != nil {
        return nil, err
    }

    // 初始化 Metrics
    prometheus.MustRegister(
        sessionsActive,
        tokenValidateCalls,
        apiRequestDuration,
        // ...
    )

    // 初始化 Logger
    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }))

    return &Observability{
        Tracer: tracer,
        Logger: logger,
    }, nil
}
```

## 8. 验收标准 (Acceptance Criteria)

### 8.1 追踪
- [ ] （可选）启用 Tracing 后，所有入站请求生成 Span
- [ ] （可选）Trace Context 正确传播（跨服务调用）
- [ ] （可选）采样策略可配置

### 8.2 指标
- [ ] 管理/业务端口（5080/5443）`/metrics` 端点返回所有定义的指标
- [ ] 指标与实际状态一致（如节点数、Session 数）
- [ ] 直方图分位数计算正确
- [ ] `/health` 和 `/ready` 端点无需鉴权

### 8.3 日志
- [ ] JSON Lines 格式输出
- [ ] 敏感信息自动脱敏
- [ ] 包含 request_id；Tracing 启用且存在 Span 时包含 trace_id/span_id

### 8.4 告警
- [ ] P0 告警能在 1 分钟内触发
- [ ] 告警消息包含足够上下文信息

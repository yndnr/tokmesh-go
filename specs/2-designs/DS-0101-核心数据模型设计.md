# DS-0101 - 核心数据模型设计

**状态**: 已批准
**优先级**: P0
**来源**: RQ-0101-核心数据模型.md, RQ-0102-会话生命周期管理.md, RQ-0201-安全与鉴权体系.md, RQ-0402-性能与可靠性需求.md, AD-0104-ID生成策略决策.md
**作者**: Gemini
**创建日期**: 2025-12-12
**最后更新**: 2025-12-18

## 1. 概述

本文档详细设计 TokMesh 的核心数据模型（Session, Token 和 API Key）及其在内存中的组织方式、持久化机制和生命周期管理。本设计目标是在高并发读写场景下提供极致性能，同时确保数据一致性和持久性。

### 1.1 ID 命名规范 (引用 RQ-0101-核心数据模型.md 第 2 节)

所有由 TokMesh 生成的 ID 遵循统一格式：`tm<type><separator><body>`

**分隔符敏感度标记**：
| 分隔符 | 敏感度 | 说明 | 日志处理 |
|--------|--------|------|----------|
| `-` (连字符) | **Public** | 可公开展示 | 可直接打印 |
| `_` (下划线) | **Sensitive** | 极度敏感 | **严禁打印明文**，必须脱敏 |

**类型代码速查**（详见 [AD-0104-ID生成策略决策](../adrs/AD-0104-ID生成策略决策.md)）：
| 前缀 | 资源类型 | 敏感度 | Body 算法 | 示例 |
|------|----------|--------|-----------|------|
| `tmss-` | Session ID | Public | ULID (小写) | `tmss-01jf8xzm7e3xqh5p8n4r6s2w0t9` |
| `tmak-` | API Key ID | Public | ULID (小写) | `tmak-01jf8y2k4m5nqp7r9s1w3x5z7a8` |
| `tmnd-` | Node ID | Public | 人工/ULID | `tmnd-prod-dc1-01` |
| `tmtk_` | Token | **Sensitive** | 32B CSPRNG Base64 | `tmtk_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijk` |
| `tmas_` | API Secret | **Sensitive** | 32B CSPRNG Base62 | `tmas_aB3dE5fG7hJ9kL1mN3pQ5rS7tU9vW1xY3zA5bC` |
| `tmth_` | Token Hash | **Sensitive** | SHA-256 Hex | `tmth_a1b2c3d4e5f6...` (69 chars) |

> **实现要求**：日志组件必须实现自动脱敏，检测 `tm*_` 前缀并替换为 `tm*_***REDACTED***`。

## 2. 核心数据结构 (Core Data Structures)

### 2.1 Session (会话) - Go Struct 定义

Session 是 TokMesh 的核心业务数据，需要高效存储和快速访问。

```go
// Session 代表一个活跃的会话实体
type Session struct {
	ID             string            `json:"id"`               // tmss-xxxxxxxxxx, SessionID, 主键
	UserID         string            `json:"user_id"`          // 关联的用户 ID
	TokenHash      string            `json:"token_hash"`       // SHA-256(明文Token) 的哈希值，用于快速查找
	IPAddress      string            `json:"ip_address"`       // 创建会话时的 IP
	UserAgent      string            `json:"user_agent"`       // 创建会话时的 User-Agent
	LastAccessIP   string            `json:"last_access_ip"`   // 最后访问 IP
	LastAccessUA   string            `json:"last_access_ua"`   // 最后访问 User-Agent
	DeviceID       string            `json:"device_id"`        // 设备唯一标识
	CreatedBy      string            `json:"created_by"`       // 创建此会话的 API Key ID
	CreatedAt      int64             `json:"created_at"`       // 创建时间 (Unix MS)
	ExpiresAt      int64             `json:"expires_at"`       // 绝对过期时间 (Unix MS)
	LastActive     int64             `json:"last_active"`      // 最后活跃时间 (Unix MS)
	Data           map[string]string `json:"data"`             // 扩展 KV 数据
	Version        uint64            `json:"version"`          // 版本号，用于乐观锁或数据冲突解决
	ShardID        uint32            `json:"-"`                // 所属分片 ID，内部使用
	TTL            int64             `json:"-"`                // 缓存 TTL，内部使用，方便过期淘汰
	IsDeleted      bool              `json:"-"`                // 逻辑删除标记，内部使用
}
```

**字段说明**:
*   `ID`: 格式 `tmss-{ulid_lowercase}`，由服务端使用 ULID 算法生成，全局唯一，时间排序。示例: `tmss-01jf8xzm7e3xqh5p8n4r6s2w0t9`
*   `TokenHash`: 存储 Token 的 SHA-256 哈希值，确保明文 Token 不落地。
*   `IPAddress`, `UserAgent`: **创建时不可变**，用于审计。
*   `LastAccessIP`, `LastAccessUA`: **每次访问更新**，反映最新访问情况。
*   `Data`: 用于存储业务自定义的 KV 数据，进行长度和大小限制。
*   `Version`: 用于实现乐观锁，解决并发更新冲突。
*   `ShardID`, `TTL`, `IsDeleted`: 内部使用字段，不暴露给外部 API，方便管理。

### 2.2 API Key (访问密钥) - 引用说明

API Key 属于安全与鉴权域的核心数据模型，其权威定义与字段约束以以下文档为准：
- `specs/1-requirements/RQ-0201-安全与鉴权体系.md`
- `specs/2-designs/DS-0201-安全与鉴权设计.md`

本设计文档仅聚焦 Session/Token 等核心业务数据模型，不在此重复定义 API Key 结构，避免多处维护导致字段漂移。

### 2.3 ID 与 Token 生成规则

#### 2.3.1 Session ID 生成 (ULID)
- **算法**: ULID (Universally Unique Lexicographically Sortable Identifier)
- **组成**: 48 位时间戳 (毫秒) + 80 位随机数 = 128 位
- **编码**: Crockford Base32 (小写)，26 字符
- **格式**: `tmss-{ulid_lowercase}`（总长 31 字符）
- **特性**: 时间排序，同一毫秒内单调递增
- **依赖**: `github.com/oklog/ulid/v2`
- **熵源**: 必须使用 `crypto/rand`，禁止使用 `math/rand`

#### 2.3.2 Token 生成 (高熵随机)
- **算法**: 使用 CSPRNG (crypto/rand) 生成 32 字节随机数 (256 位熵)
- **编码**: Base64 RawURL 编码 (A-Z, a-z, 0-9, -, _)，固定长度 43 字符 (不含前缀)
- **格式**: `tmtk_<base64_encoded_32_bytes>`（总长 48 字符）
- **敏感标记**: 使用下划线 `_` 分隔符，表示该凭证极度敏感，严禁在日志中打印明文
- **安全要求**: 严禁使用 ULID/UUID 等可预测算法生成 Token（详见 [AD-0104-ID生成策略决策](../adrs/AD-0104-ID生成策略决策.md)）

#### 2.3.3 Token Hash 存储
- 明文 Token 不存储，只存储其 SHA-256 哈希值 (`TokenHash`)
- `TokenHash` 字段在本地分片中维护**唯一索引**，确保一个 Token 对应一个 Session。
- 冲突处理: 并发创建相同 `TokenHash` 的 Session 时，只允许一个成功，其余返回冲突错误。

### 2.4 数据约束 (基于 RQ-0101-核心数据模型.md)

| 字段 | 类型 | 最大长度/约束 |
|------|------|--------------|
| `UserID` | string | 128 字符 |
| `IPAddress` | string | 45 字符 (IPv6) |
| `UserAgent` | string | 512 字符 |
| `DeviceID` | string | 128 字符 |
| `Data` | map | 总计 4KB, 单 key 不超过 64 字符, 单 value 不超过 1KB |
| **用户配额** | - | 单用户最多 50 个活跃 Session |

## 3. 内存存储结构 (In-Memory Storage)

每个 TokMesh 节点维护一个本地数据分片，仅存储属于该节点 Owner 的 vNode 上的 Session 数据。

### 3.1 Session 主索引

*   **结构**: `sync.Map` 或定制的 `ConcurrentMap` (使用 `shard` + `sync.RWMutex`)。
*   **Key**: `Session.ID`。
*   **Value**: `*Session` 指针。
*   **并发访问**: 读写需要高效的并发控制。

### 3.1.1 并发控制选型
-   **推荐方案**: **分段锁 ConcurrentMap** (16 个 shard)
    -   适用于读写均衡场景
    -   10,000 TPS 下锁冲突率 < 5%
-   **备选方案**: sync.Map（Go 1.9+）
    -   适用于读多写少（读写比 > 10:1）
    -   写密集场景性能下降明显
-   **决策依据**: 参见 [AD-0102-并发Map选型决策.md](../adrs/AD-0102-并发Map选型决策.md)

### 3.2 Token Hash 索引

*   **结构**: `sync.Map` 或定制 `ConcurrentMap`。
*   **Key**: `Session.TokenHash`。
*   **Value**: `Session.ID` (避免内存冗余)。
*   **用途**:
    1.  **快速查找**: 用于根据 `TokenHash` 快速定位 `SessionID`。
    2.  **Token 校验流程**: 结合 `Session` 主索引，实现完整的 Token 校验：
        a.  接收到明文 Token 后，计算其 `TokenHash`。
        b.  通过 `TokenHash` 索引查找对应的 `SessionID`。
        c.  再通过 `SessionID` 在主索引 `(3.1)` 中检索到完整的 `Session` 对象。
        d.  对获取的 `Session` 对象执行业务校验（例如：`ExpiresAt` 是否过期、`IsDeleted` 标记等）。

### 3.3 二级索引

*   **结构**: 基于 `map[string]map[SessionID]struct{}` 或 `sync.Map` 的多级索引。
*   **Key**: `UserID`, `DeviceID`, `CreatedBy` 等。
*   **Value**: 关联的 `Session.ID` 集合。
*   **用途**: 支持按 `UserID` 查找所有会话（例如批量吊销）。

### 3.3.1 二级索引维护策略
-   **更新时机**: 与主索引**同步更新**（在同一个 RWMutex 临界区内）
-   **一致性保证**: 事务性更新（要么全部成功，要么全部失败）
-   **失效处理**: 启动时从主索引重建所有二级索引

## 4. 持久化机制 (Persistence)

TokMesh 采用高性能 **WAL (预写日志)** + **周期性快照 (Snapshot)** 的方式实现数据持久化。

### 4.1 WAL (Write-Ahead Log)

*   **机制**: 所有对 Session 数据的写操作（Create, Update, Delete）必须先写入 WAL，成功后才修改内存数据。
*   **格式**: 基于 Protobuf (性能优于 JSON)。
    *   `WalEntry`: `type` (CREATE/UPDATE/DELETE), `timestamp`, `Session` 数据 (Full Session 或 Delta)。
*   **实现**: Append-only Log，支持批量写入，可配置 `fsync` 策略（sync/batch）。
*   **安全性**: WAL 数据必须加密存储 (参见 `security.storage.wal_encryption_key`)。
*   **路径**: 可通过 `storage.wal.dir` 配置 WAL 文件存储路径。

### 4.1.1 WAL 批量写入策略
-   **批量大小**: 默认 100 条 or 1MB (先到者触发)
-   **fsync 时机**:
    -   **同步模式 (sync)**: 每批次立即 fsync，RPO = 0
    -   **批量模式 (batch)**: 按 `sync_interval` 定时触发 fsync，RPO ≤ sync_interval
    -   配置项: `storage.wal.sync_mode` (`sync` / `batch`)
-   **性能权衡**: batch 模式 TPS 提升 3-5 倍，但故障时可能丢失最近一个 sync_interval 内的数据

### 4.1.2 WAL 加密
-   **算法**: **自适应 (Adaptive)**
    -   硬件加速可用时: **AES-256-GCM** (AES-NI / ARMv8 Crypto)
    -   软件回退时: **ChaCha20-Poly1305**
-   **密钥管理**: 从配置文件读取 32 字节密钥 `security.storage.wal_encryption_key`
-   **一致性**: 无论使用何种算法，统一使用 32 字节密钥和 12 字节 Nonce。
-   **性能开销**: 硬件加速下 < 5%，软件回退下 < 15%。

### 4.2 周期性快照 (Snapshots)

*   **机制**: 定期将内存中的全量 Session 数据序列化并持久化到磁盘，生成快照文件。
*   **用途**: 加速重启恢复。
*   **流程**:
    1.  创建内存副本。
    2.  对副本进行序列化 (Protobuf)。
    3.  写入临时文件。
    4.  重命名为正式快照文件。
*   **安全性**: 快照数据也需加密存储。加密算法与 WAL 保持一致（自适应 AES-GCM / ChaCha20）。

### 4.2.1 快照触发条件
-   **时间触发**: 每 1 小时 (可配置 `storage.snapshot.interval`)
-   **WAL 大小触发**: WAL 累积超过 1GB (可配置 `storage.snapshot.threshold`)
-   **手动触发**: 通过 tokmesh-cli 命令

### 4.2.2 并发写入处理
-   **Copy-on-Write**: 创建内存数据的快照视图（Go 中可用 sync.RWMutex 实现）
-   **写入继续**: 快照期间新写入继续记录到 WAL，不阻塞业务
-   **原子切换**: 快照文件生成后，原子性重命名 (rename) 替换旧快照

### 4.3 故障恢复 (Recovery)

1.  **加载最新快照**: 启动时加载最新的快照文件，快速恢复大部分内存数据。
2.  **回放 WAL**: 从最新快照点开始，顺序回放 WAL 中剩余的日志条目，将内存数据恢复到故障发生前的状态。
3.  **并发与容错**: 恢复过程需支持断点续传和并发回放。

### 4.3.1 冷启动时间优化
-   **目标**: < 5s (符合 RQ-0402-性能与可靠性需求.md)
-   **策略**:
    1.  优先加载快照（并行 I/O，预期 < 2s）
    2.  回放 WAL：从最新快照点开始，顺序回放**全部** WAL 条目，确保内存状态与持久化一致
    3.  并行优化：WAL 解码/应用与必要的索引构建可并行化（但对单条日志的应用仍保持顺序语义）
-   **就绪语义（必须明确）**:
    - `/ready` 仅在“快照加载 + WAL 回放完成，读写路径一致且可用”时返回 200。
    - 若 5s 内无法完成恢复：保持 `/ready` 为非就绪（例如 503），而不是隐式进入“Ready 但只读”的降级模式（避免一致性语义漂移）。

## 5. 生命周期管理 (Lifecycle Management)

> 详细流程定义请参见 [RQ-0102-会话生命周期管理](../1-requirements/RQ-0102-会话生命周期管理.md)

### 5.1 TTL (Time-To-Live) 机制

*   **机制**: Session 在创建时被赋予 `ExpiresAt`。
*   **惰性删除**: 访问 Session 时检查 `ExpiresAt`，若过期则视为不存在。
*   **主动清理**: 后台任务周期性扫描内存中的过期 Session。
    *   **算法**: 随机抽取少量 Session，若过期则删除。效率高，开销低。
    *   **频率**: 可配置 (e.g., `session.ttl.gc_interval`)。
    *   **与 WAL 交互**: 被主动清理的 Session 需在 WAL 中标记为 `DELETE`，并通过 Replication Stream 传播。

### 5.1.1 TTL 主动清理算法（采样驱逐）
1.  **触发频率**: 每 100ms 执行一次清理周期 (可配置)
2.  **采样策略**:
    -   随机抽取 **20 个** Session (可配置 `session.ttl.sample_size`)
    -   检查 `ExpiresAt`，删除所有过期 Session
3.  **递归条件**:
    -   如果过期比例 > 25%，立即再次采样
    -   最多递归 4 次，避免阻塞
4.  **WAL 交互**: 删除操作写入 WAL (type=DELETE)
5.  **性能开销**: 单次采样 < 1ms, CPU 占用 < 1%

### 5.2 并发与乐观锁

*   **问题**: Session 数据可能被多个请求并发修改（例如 Validate 和 Renew）。
*   **机制**: 引入 `Session.Version` 字段。每次更新递增 `Version`，并利用乐观锁 (Compare-And-Swap) 机制。
*   **冲突解决**: 若并发更新导致版本冲突，则重试或返回冲突错误。

### 5.2.1 Version 字段语义
-   **作用域**: 仅在 Session Owner 节点内有效
-   **并发控制**: 用于单节点内的乐观锁 (CAS)
-   **跨节点复制**: Version 随 Session 一起复制，但 Replica 节点不校验 Version
-   **限制**: 不适用于解决跨节点并发修改冲突（集群模式下禁止多节点同时修改同一 Session）

## 6. 与控制面 (Raft) 的交互

*   **Cluster Map 同步**: 本地节点通过 Raft Learner 机制，从 Leader 获取最新的 Shard Map，维护 `Session.ShardID` 到 `Owner Physical Node ID` 的映射。
*   **API Key 策略**: 从 Raft 获取 `API Key` (及其 ACL, Rate Limit) 配置，用于鉴权。
*   **一致性**: 对这些元数据的读取必须是线性一致的 (ReadIndex)。

## 7. 未决问题 (Open Questions)

*   自定义 WAL 的具体实现细节（文件滚动、损坏恢复）。
*   内存 ConcurrentMap 的具体实现（分段锁、无锁）。
*   如何优雅地支持 Session 数据加密（如果需要对 WAL/快照以外的内存数据加密）。

## 8. 验收标准 (Acceptance Criteria)

### 8.1 功能验收（引用 RQ-0101, RQ-0102）
参见 `RQ-0101-核心数据模型.md` 和 `RQ-0102-会话生命周期管理.md`。

### 8.2 性能验收（设计层面）
- [ ] **内存索引性能**: 单节点支持 100 万 Session，查询延迟 P99 < 1ms
- [ ] **WAL 写入性能**: batch 模式下吞吐量 ≥ 20,000 writes/s
- [ ] **快照生成时间**: 100 万 Session 快照生成 < 10s
- [ ] **故障恢复时间**: 冷启动（含快照加载 + WAL 回放）< 5s
- [ ] **TTL 清理效率**: 过期 Session 在 5 分钟内被清理（99% 概率）
